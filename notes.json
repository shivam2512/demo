[
  {
    "date": "19-NOV-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--DCL (Grant and revoke)\n--to create a new user\ncreate user dbs4 identified by admin;\n\n--to grant session access\ngrant create session to dbs4;\n\n--to grant access to db table\ngrant select, insert, update on emp to dbs4;\n\n--to revoke access from table:\nrevoke select on emp from dbs4;\n\n--to drop a user (before dropping user should be disconnected)\ndrop user dbs4;",
    "time": "09:00 PM"
  },
  {
    "date": "20-NOV-2025",
"session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "body": "-- Types of SQL commands:\n--1. DDL\n--a. CREATE (to create database object)\ncreate table emp2\n(\nemp_id number,\nemp_name varchar2(50),\ndepartment varchar2(30),\nsalary number(10,2)\n);\n\ndesc emp2;\n\n--b. ALTER (to make any changes in database object structure)\nalter table emp2 add hire_date date; -- to add new column\nalter table emp2 drop column salary; -- to remove exisitng column\nalter table emp2 rename COLUMN department to dept; -- to rename column\nalter table emp2 modify dept char(30); -- to modify dataype of column\n\n--c. Rename:\nrename emp2 to emp3;\n\n--d. DROP and TRUNCATE\n--d.1. DROP - (it is used to delete all data + structure)\ndrop table emp3;\n\n--d.2. TRUNCATE - (it is used to delete all data but structure remains as it is)\ntruncate table emp3;\n\n--2. DML ()\n--a. INSERT (is used to insert data in table)\ninsert into emp2 values (1,'A','IT',10000);\ninsert into emp2 (emp_id, emp_name) values (6,'F');\ninsert into emp2 values (2,'B','CS',11000);\ninsert into emp2 values (3,'C','CS',23000);\ninsert into emp2 values (4,'D','IT',14000);\ninsert into emp2 values (5,'E','IT',15000);\n\n--b. UPDATE (is used to update the data in table)\nupdate emp2 set department='CS', salary=15000 where emp_id=6;\n\n--c. DELETE (to delete the data from table)\ndelete from emp2 where emp_id=6;",
"time": "03:00 PM"

  },
{
    "date": "20-NOV-2025",
"session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "body":  "-- Types of SQL commands:\n--1. DDL (Data Definition language) - create, alter, rename, drop, truncate\n--a. CREATE (to create database object)\ncreate table emp2\n(\n  emp_id number,\n  emp_name varchar2(50),\n  department varchar2(30),\n  salary number(10,2)\n);\n\ndesc emp2;\n\n--b. ALTER (to make any changes in database object structure)\nalter table emp2 add hire_date date; -- to add new column\nalter table emp2 drop column salary; -- to remove exisitng column\nalter table emp2 rename COLUMN department to dept; -- to rename column\nalter table emp2 modify dept char(30); -- to modify dataype of column\n\n--c. Rename:\nrename emp2 to emp3;\n\n--d. DROP and TRUNCATE\n--d.1. DROP - (it is used to delete all data + structure)\ndrop table emp3;\n\n--d.2. TRUNCATE - (it is used to delete all data but structure remains as it is)\ntruncate table emp3;\n\n--2. DML (Data Manipulation Language): insert, delete, update\n--a. INSERT (is used to insert data in table)\ninsert into emp2 values (1,'A','IT',10000);\ninsert into emp2 (emp_id, emp_name) values (6,'F');\ninsert into emp2 values (2,'B','CS',11000);\ninsert into emp2 values (3,'C','CS',23000);\ninsert into emp2 values (4,'D','IT',14000);\ninsert into emp2 values (5,'E','IT',15000);\n\n--b. UPDATE (is used to update the data in table)\nupdate emp2 set department='CS', salary=15000 where emp_id=6;\n\n--c. DELETE (to delete the data from table)\ndelete from emp2 where emp_id=6;",
"time": "09:00 PM"
},
{
    "date": "21-NOV-2025",
"session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "body": "-- DQL (Data Query Language) : is used to fetch the data from table-- SELECT\n\nselect * from emp_master;\n\n--Operators that can be used with select statements:\n\n--1. where clause: (to give any specific condition for data retrieval)\nselect * from emp_master where emp_name='D';\n\n--2. order by: (to arrange the data in specific order asc or desc)\nselect * from emp_master order by emp_name asc;\n\n--3. LIKE (to fetch the data based on any given pattern)\nselect * from emp_master where emp_name like '% Gupta';\n\n--4. DISTINCT: (is used to fetch the unique records and it discards the duplicate entry in output)\nselect distinct emp_id, emp_name, salary, department from emp_master;\n\n--5. BETWEEN (to view the data between given range)\nselect * from emp_master where salary between 10000 and 13000;\n\n--6. IN (is used to fetch the record with the matching values)\nselect * from emp_master where salary in (10000,12000);\n\n--7. IS NULL (to check if the column value is null or not)\nselect * from emp_master where salary is null;\n\n\nupdate emp_master set emp_name ='Anuj Gupta' where emp_id=2;",
"time": "03:00 PM"
},
{
    "date": "23-NOV-2025",
"session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--How to backup any table:\ncreate table emp_bkp as select * from emp1;\n\n--Table and Column comment:\n\n--1. Comment on Table- adds description for entire table:\nselect * from emp_bkp;\ncomment on table emp_bkp is 'It is the backup table for emp1 table';\nselect * from user_tab_comments where table_name ='EMP_BKP';\n\n--2. Comment on Column- adds description for a specific column\nselect * from emp_bkp;\ncomment on column emp_bkp.gender is 'It will store user gender info.';\nselect * from user_col_comments where table_name ='EMP_BKP';\n\n--Alter, Update: (revision)\n--Alter -- DDL (auto committed)\nselect * from emp_bkp;\ndesc emp_bkp;\n\n--Alter\nalter table emp_bkp add emp_name varchar(40);\nalter table emp_bkp drop column emp_name;\nalter table emp_bkp rename column gender to emp_gender;\nalter table emp_bkp modify emp_gender varchar2(5);\n\n--update (DML):\nselect * from emp_bkp;\ndesc emp_bkp;\nupdate emp_bkp set emp_name='Aman', emp_id=1;\n\ncommit;",
"time": "09:00 PM"
},
{
    "date": "24-NOV-2025",
"session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--DCL (Data Control Language)\n--DCL is used to control access rights and permissions on database objects\n--like tables, views, sequences, indexes, procedures, triggers etc.\n-->> GRANT and REVOKE\n\n--GRANT -- to give the access of db object to any user\n--CREATE a user\ncreate user demo_user identified by admin;\n\n-- To give session access\ngrant create session to demo_user;\n\n-- To view all system users\nselect * from all_users where username ='DEMO_USER';\n\n-- GRANT table access\nGRANT select, insert, update ON EMP_MASTER TO demo_user;\n\n--Revoke: to take back/remove the access from db object.\nrevoke delete on emp_master from demo_user;\n\n--COMMENT: to add any descripion or info..\n--1. Single line comment: --\n--2. Multi line comments: /* */",
"time": "03:00 PM"
},
{
    "date": "24-NOV-2025",
"session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--3. DQL/DRL: (Data Query Language/ Data Retrieval Language)\n--1. SELECT (To fetch the data from DB table/object)\ndesc emp_master;\nselect * from emp_master;\n\n--Operators/Clauses: a. where clause\nselect * from emp_master where emp_id=2;\n\n--b. order by: (to sort data in asc or desc order):\nselect * from emp_master order by emp_name;\n\n--c. distinct keyword: (used to print unique data from table)\nselect distinct emp_id, emp_name, emp_gender from emp_master;\n\n--d. like: (to fetch the data based on specific pattern)\nselect * from emp_master where emp_name like 'R% Gupta';\n\n--e. IN operator: (to fetch the data based given value in operator)\nselect * from emp_master where emp_name in ('Rohit Gupta');\n\n--f. between: (to fetch the data between given range)\nselect * from emp_master where emp_id between 1 and 3;\n\n--g. is null: (used to fetch null record from table)\nselect * from emp_master where emp_gender is null;\nselect * from emp_master where emp_gender is not null;\n\n--h. =,>,<\nselect * from emp_master where emp_id >= 1;\nselect * from emp_master where emp_id <= 6;",
"time": "09:00 PM"
},
{
    "date": "25-NOV-2025",
"session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--DML (Merge): Merge is used when we want to update a row if its exists or\n--insert a new row if its does not exist.\n\ncreate table emp_main\n(\n  id number(5),\n  name varchar(50),\n  salary number(8)\n);\n\ncreate table emp_new\n(\n  id number(5),\n  name varchar(50),\n  salary number(8)\n);\n\ninsert into emp_main values (101, 'Rahul',30000);\ninsert into emp_main values (102, 'Sneha',35000);\n\ninsert into emp_new values (101, 'Rahul',40000);\ninsert into emp_new values (103, 'Amit',28000);\n\nselect * from emp_new;\n\n--What we need:\n--if emp already exist --> Update query\n--if emp does not exist --> insert query\n\nmerge into emp_main m\nusing emp_new n\non (m.id=n.id)\nwhen matched then\nupdate set m.salary=n.salary -- update exisitng employee\n\nwhen not matched then\ninsert (id, name, salary) -- insert new employee data\nvalues (n.id,n.name,n.salary);\n\nselect * from emp_main;\n\n--TCL (Transaction control language): is used to control changes in database. It\n--decides whether our changes should be saved or undone.\n\n--COMMIT: is used to save the changes permanently in db memory\n--DDL (CREATE, ALTER, RENAME, DROP, TRUNCATE) -- AUTO COMMITTED\n--DML (INSERT, UPDATE, DELETE, MERGE) -- We need to commit or rollback it to save or\n--undo the changes\n\ninsert into emp_new values (104,'Rohan', 40000);\ninsert into emp_new values (105,'Ram', 30000);\ninsert into emp_new values (106,'Shyam', 41000);\ncommit;\n\n--ROLLBACK: to undio the changes before commit.\ninsert into emp_new values (107,'Ajay', 25000);\ninsert into emp_new values (108,'Avinash', 50000);\ninsert into emp_new values (109,'Gautam', 40000);\nrollback;\n\nselect * from emp_new;\n\n--SAVEPOINT: Marks a point within a transaction to which you can roll back.\n\nINSERT INTO emp_new VALUES (107, 'Ajay',45000);\nSAVEPOINT sp1;\n\nINSERT INTO emp_new VALUES (108, 'Gautam',35000);\nsavepoint sp2;\n\nDELETE FROM emp_new WHERE id = 101;\n\n-- Rollback to a savepoint (only undoes statements after sp1)\nROLLBACK TO sp2;\n\n-- Commit remaining changes\nCOMMIT;",
"time": "03:00 PM"
},
{
    "date": "25-NOV-2025",
"session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--DML (Merge): Merge is used when we want to update a row if its exists or\n--insert a new row if its does not exist.\n\n--using below tables on merge\n--emp_main\n--emp_new\n\ncreate table emp_main\n(\n  id number(5),\n  name char(50),\n  salary number(8)\n);\n\ncreate table emp_new\n(\n  id number(5),\n  name varchar(50), ffh3\n  salary number(8)\n);\n\ndesc emp_new;\n\ninsert into emp_main values (101, 'Rahul',30000);\ninsert into emp_main values (102, 'Sneha',35000);\n\ninsert into emp_new values (101, 'Rahul',40000);\ninsert into emp_new values (103, 'Amit',28000);\n\n--What we need:\n--if emp already exist --> Update query\n--if emp does not exist --> insert query\n\nmerge into emp_main m\nusing emp_new n\non (upper(m.name)=upper(n.name))\nwhen matched then\nupdate set m.salary=n.salary ;-- update exisitng employee data\nwhen not matched then\ninsert (id, name, salary) -- insert new employee data\nvalues (n.id,n.name,n.salary);",
"time": "09:00 PM"
},
{
    "date": "26-NOV-2025",
"session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "body": "----DCL (Data Control Language): It is used to give access or to revoke the access db users\n--1. GRANT (To give access of any db object to the user):\n\n--create a new user\ncreate user dbs4 identified by admin;\n\n--to grant session access to user\ngrant create session to dbs4;\n\n--GRANT:\ngrant select, insert, delete, update on emp_main to dbs4;\n\n--2. REVOKE: (To take back the access control of fb object from user)\nrevoke insert, delete, update on emp_main from dbs4;\n\n-- to know the table owner:\nselect owner, table_name from all_tables where table_name ='EMP_MAIN';\n\n-- to check all users details\nselect * from all_users ;\n\n--Revision:\n--Binary Data Types ()\n--1. RAW (used to store small binary data up to 2000 bytes)\n--2. LONG RAW (used to store large binary data up to 2 GB)\n--3. BLOB (Binary Large Object): used to store very large binary data, up to 128 TB\n\n--creating a table\ncreate table raw_demo\n(\n  id number,\n  data raw(20) --similarly you can use long raw and blob\n);\n\nSELECT * FROM raw_demo;\n\ninsert into raw_demo values (1,HEXTORAW('A1B2C3D4'));",
"time": "03:00 PM"
},
{
    "date": "26-NOV-2025",
    "title": "Practice Session",
"subject": "SQL",
"session": "Evening",
    "body": "--TCL (Transaction Control Language): It is used to save or revrt back the transaction operations in db memory.\n\n--DDL : this are auto-committed (create, alter, drop, truncate, rename)\n--DML : (insert, update, delete, merge)\n\n-- 1. COMMIT: is used to save the operation result permanently in db memory\nselect * from emp_new;\n\ninsert into emp_new values (104,'Rohit',35000);\ninsert into emp_new values (105,'Aman',45000);\ncommit;\n\nselect * from emp_new;\n\n-- 2. ROLLBACK: is used to revert back/undo the changes/operation result\n\ninsert into emp_new values (106,'Sneha',25000);\ninsert into emp_new values (107,'Sahil',15000);\n\nrollback;\n\n-- 3. SAVEPOINT: Marks a point within a transaction to which you can roll back.\n\nINSERT INTO EMP_NEW VALUES (106, 'Sahil', 30000);\nSAVEPOINT sp1;\n\nINSERT INTO emp_new VALUES (107, 'Sneha',40000);\nSAVEPOINT sp2;\n\nDELETE FROM emp_new WHERE id = 101;\n\n-- Rollback to a savepoint (only undoes statements after sp1)\nROLLBACK TO sp1;\n\n-- Commit remaining changes\nCOMMIT;",
"time": "09:00 PM"
},
{
    "date": "27-NOV-2025",
"session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--Restrict and Sort Data:\n--1. where clause:  (is used to fetch the data based on certain condition)\nselect * from emp_new where id=101;\n\n--2. order by: (is used to sort data in asc or desc order):\nselect * from emp_new order by id desc;\n\n--3. Arithmetic operators: (+,-,*,/)\n--(+): is used to add numbers:\nselect 10 + 5 + 5 as result from dual;\n\n--(-): We can subtract the values:\nselect 15 - 5 - 5 as result from dual;\n\n--(*):  to perform multiplication:\nselect 5 * 10 as result from dual;\n\n--(/):  to perform division:\nselect 50 / 10 as result from dual;\nselect 10 +  nvl(null,0) as result from dual;\n\n--BODMAS rule: (Bracket, Off, Division, mul, add, sub):\nselect 10 + 20 * 3 - (8 / 2 + 6) * 2 as result from dual;\n--Inner bracket: 8 / 2= 4\n--Inner addition: 4 + 6 = 10\n--Multiply: 10 * 2 = 20\n--Main: 10 + 20 * 3 - 20\n--Multiply: 20 * 3 = 60\n--Final: 10 + 60 - 20= 70 - 20 = 50\n\n--Comparison and relational operators:\n--1. = equals to\nselect * from emp_new where salary = 50000;\n\n--2. != or <>\nselect * from emp_new where salary != 50000;\n\n--3. > (greater than),  < (less than)\nselect * from emp_new where salary > 30000;\nselect * from emp_new where salary < 30000;\n\n--4. >= (greater than equals to) , <= (less than equals to)\nselect * from emp_new where salary >= 30000;\nselect * from emp_new where salary <= 30000;\n\n--LOGICAL operators:\n--(AND, OR, NOT)\n--1. AND: All conditions should be true.\nselect * from emp_new where id =101 AND name='Rahul' and salary=50000;\n\n--2. OR: At least one condition must be true\nselect * from emp_new where id=101 OR name='Sahil';\n\n--3. NOT: Reverses the condition(true becomes false)\nselect * from emp_New where not salary=50000 ;\n\n--DESC Keyword: is used to describe db object;\ndesc emp_new;\n--TO COUNT TABLE COLUMN VALUES\nselect count(*) from user_tab_columns where table_name ='EMP_NEW';",
"time": "03:00 PM"
},
{
    "date": "27-NOV-2025",
"session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "body": "--DCL (Data Control Language): is used for providing or removing the access preveliege to users on db objects\n\n--to create a new user:\ncreate user dbs5 identified by admin;\ngrant create session to dbs5;\n\n--access using dbs5 user:\nselect * from system.emp_new;\ninsert into system.emp_new values (107, 'Rohan',12000);\n\ndelete from system.emp_new where id=101;\n\nupdate system.emp_new set id=108 where id=103;\n\n--1. Grant: is used to provide the access of DB object to user.\ngrant  on emp_new to dbs5;\n\n--2. Revoke: is used to remove the access of DB object from user.\nrevoke update, delete, insert on emp_new from dbs5;",
"time": "09:00 PM"
},
  {
    "date": "28-NOV-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:21 PM",
    "body": "--DISTINCT Keyword: is used to remove duplicate values from the result. It will show only unique values.\nselect * from emp_new;\n\nselect distinct * from emp_new order by id;\ninsert into emp_new values (101,'rahul', 30000);\ninsert into emp_new values (102,'Sneha', 35000);\nselect * from emp_new;\nselect * from emp_main;\n\n--SET Operators: are used to combine the results of two select queries.\n--1. UNION: removes duplicates and shows unique values from both tables.\nselect * from emp_main\nunion\nselect * from emp_new;\n\n--2. UNION ALL: keeps all values including duplicates.\nselect * from emp_main\nunion all\nselect * from emp_new;\n\n--3. INTERSECT: shows common values that exist in both tables:\nselect * from emp_new\nintersect\nselect * from emp_main;\n\n--4. MINUS: shows the values from the first query that are not in the second query.\nselect * from emp_new\nminus\nselect * from emp_main;\n\n--SPECIAL OPERATOR: REGEXP: is used to match patterns in text.\n--1. REGEXP_LIKE: used in where clause to match a pattern (similar to like but more powerful)\nselect * from emp_new where regexp_like (name,'^.{4}$');\nselect * from emp_new where name like '%';\n--2. REGEXP_REPLACE: used to replace the text using a pattern\nselect regexp_replace('Ph: 987-654-3210', '[^0-9]', '') as cleaned_num from dual;\nselect regexp_replace('Amit    Rohan    TCS', '\\s+', ' ') as result from dual;"
  },
  {
    "date": "28-NOV-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:31 PM",
    "body": "--Restrict and Sort Data:\n--1. where clause:  (is used to fetch the data based on certain condition)\nselect * from emp_new where id=104;\n\n--2. order by: (is used to sort data in asc or desc order):\nselect * from emp_new order by name;\n\n--3. Arithmetic operators: (+,-,*,/)\n--(+): is used to add numbers:\nselect 10 + 5 as result from dual;\n\n--(-): We can subtract the values:\nselect 15 - 5  as Subtract from dual;\n\n--(*):  to perform multiplication:\nselect 5 * 10 as result from dual;\n\n--(/):  to perform division:\nselect 50 / 10 as result from dual;\n\nselect 10 +  nvl(null,0) as result from dual;\n\n--BODMAS rule: (Bracket, Off, Division, mul, add, sub):\nselect 10 + 20 * 3 - (8 / 2 + 6) * 2 as result from dual;\n--Inner bracket: 8 / 2= 4\n--Inner addition: 4 + 6 = 10\n--Multiply: 10 * 2 = 20\n--Main: 10 + 20 * 3 - 20\n--Multiply: 20 * 3 = 60\n--Final: 10 + 60 - 20= 70 - 20 = 50"
  },
  {
    "date": "29-NOV-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:18 PM",
    "body": "--Comparison and relational operators:\n--1. = equals to\nselect * from emp_new where id = 107;\n\n--2. != or <>\nselect * from emp_new where salary <> 30000;\n\n--3. > (greater than),  < (less than)\nselect * from emp_new where salary > 30000;\nselect * from emp_new where salary < 30000;\n\n--4. >= (greater than equals to) , <= (less than equals to)\nselect * from emp_new where salary >= 30000;\nselect * from emp_new where salary <= 30000;\n\n--LOGICAL operators:\n--(AND, OR, NOT)\n\n--1. AND: All conditions should be true.\nselect * from emp_new where id =110 AND name='Sahil';\n\n--2. OR: At least one condition must be true\nselect * from emp_new where id=110 OR name='Sahil';\n\n--3. NOT: Reverses the condition(true becomes false)\nselect * from emp_New where not salary=30000 ;\n\n--DESC Keyword: is used to describe db object;\ndesc emp_new;\n\n--DISTINCT Keyword: is used to remove duplicate values from the result. It will show only unique values.\nselect distinct * from emp_new;\n\n--SET Operators: are used to combine the results of the select queries.\n--1. UNION: removes duplicates and shows unique values from the tables.\nselect * from emp_main\nunion\nselect * from emp_new\nunion\nselect * from emp_new1;\n\n--2. UNION ALL: keeps all values including duplicates.\nselect * from emp_main\nunion all\nselect * from emp_new\nunion all\nselect * from emp_new1;\n\n--3. INTERSECT: shows common values that exist in both tables:\nselect * from emp_new\nintersect\nselect * from emp_main\nintersect\nselect * from emp_new1;\n\n--4. MINUS: shows the values from the first query that are not in the second query.\nselect * from emp_new\nminus\nselect * from emp_main\nminus\nselect * from emp_new1;"
},
{
"date": "29-NOV-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:15 PM",
    "body": "--Comparison and relational operators:\n--1. = equals to\nselect * from emp_new where name = 'Amit';\n\n--2. != or <>\nselect * from emp_new where salary <> 30000;\n\n--3. > (greater than),  < (less than)\nselect * from emp_new where salary > 30000;\nselect * from emp_new where salary < 30000;\n\n--4. >= (greater than equals to) , <= (less than equals to)\nselect * from emp_new where salary >= 30000;\nselect * from emp_new where salary <= 30000;\n\n--LOGICAL operators:\n--(AND, OR, NOT)\n\n--1. AND: All conditions should be true.\nselect * from emp_new where id =106 AND name='Sahil';\n\n--2. OR: At least one condition must be true\nselect * from emp_new where id=110 or name='Sahil';\n\n--3. NOT: Reverses the condition(true becomes false)\nselect * from emp_New where not salary = 30000 ;\n\n--DESC Keyword: is used to describe db object;\ndesc emp_new;\n\n--DISTINCT Keyword: is used to hide duplicate values from the result. It will show only unique values.\nselect  distinct * from emp_new;\n\n--SET Operators: are used to combine the results of the select queries.\n--1. UNION: removes duplicates and shows unique values from the tables.\nselect * from emp_main\nunion\nselect * from emp_new;\n\n--2. UNION ALL: keeps all values including duplicates.\nselect * from emp_main\nunion all\nselect * from emp_new;"
},
{
    "date": "01-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "03:45 PM",
    "body": "--Special operator: REGEXP: it stands for Regular Expressions. It is used\n--to search, match, extract or replace text in a smarter way than normal like\n\n--LIKE: simple pattern matching\n--REGEXP: advanced pattern matching (numbers, letters, words, formats)\n\n--Types of REGEXP:\n--1. REGEXP_LIKE: used to check if a value matches a pattern:\n--EG: find names starting with A\nselect * from emp_new where REGEXP_LIKE(name, '^A');\n\n--eg: find names containing digits\nselect * from emp_new where regexp_like(name,'[0-9]');\n\n--2. REGEXP_REPLACE: used to remove or replace parts of the text:\n--eg: remove all numbers:\nselect id, regexp_replace(name, '[0-9]','') as name, salary  from emp_new ;\n--eg: replace multiple spaces with no space:\nselect id, regexp_replace(name, '\\s+','') as name, salary  from emp_new ;\n\n--3. REGEXP_SUBSTR: is used to extract the certain part from the column data.\n--eg: to fetch the first name of the users:\nselect id, regexp_substr(name, '[^ ]+') as name, salary from emp_new;\n--eg: to fetch only digits inside the name column\nselect id, salary, regexp_substr(name, '[0-9]+') as name  from emp_new;\n\n--4. REGEXP_INSTR: to find position where a number/letter appears in the column data\nselect id, regexp_instr(name, 't') as letter_postion, salary from emp_new;\n\n--5. REGEXP_COUNT: is count how many times a pattern occurs\n--eg: count digits, letters and speciaal characters in the name column:\nselect id, regexp_count(name,'[A-Za-z0-9 ]') as count, salary from emp_new;"
},
{
    "date": "01-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "09:40 PM",
    "body": "--SET Operators: are used to combine the results of the select queries.\n--1. UNION: removes duplicates and shows unique values from the tables.\nselect * from emp_main\nunion\nselect * from emp_new;\n\n--2. UNION ALL: keeps all values including duplicates.\nselect * from emp_main\nunion all\nselect * from emp_new\nunion all\nselect * from emp_new1;\n\n--3. INTERSECT: shows common values that exist in both tables:\nselect * from emp_new\nintersect\nselect * from emp_main;\n\n--4. MINUS: shows the values from the first query that are not in the second query.\nselect * from emp_new\nminus\nselect * from emp_main;\n\n--Special operator: REGEXP: it stands for Regular Expressions. It is used\n--to search, match, extract or replace text in a smarter way than normal like\n\n--LIKE: simple pattern matching\n--REGEXP: advanced pattern matching (numbers, letters, words, formats)\n\n--Types of REGEXP:\n--1. REGEXP_LIKE: used to check if a value matches a pattern:\n--EG: find names starting with A\nselect * from emp_new where REGEXP_LIKE(name, '^A');\n\n--eg: find names containing digits\nselect * from emp_new where regexp_like(name,'[0-9]');\n\n--2. REGEXP_REPLACE: used to remove or replace parts of the text:\n--eg: remove all numbers:\nselect id, regexp_replace(name, '[0-9]','') as name, salary  from emp_new ;\n\n--eg: replace multiple spaces with no space and give space between first and last name:\nselect id,\nregexp_replace(\ntrim(regexp_replace(name, '\\s+', ' ')), -- A mitSharma\n'^(\\S+)\\s+(.*)$',\nregexp_replace('\\1','\\s', '') || '' || '\\2'\n)as name, salary from emp_new;\n\n--3. REGEXP_SUBSTR: is used to extract the certain part from the column data.\n\n--eg: to fetch the last name of the users:\nselect id, regexp_substr(name, '\\S+$') as name, salary from emp_new;\n\n--eg: to fetch the first name of the users:\nselect id, regexp_substr(name, [^ ]+) as name, salary from emp_new;\n\n--eg: to fetch only digits inside the name column\nselect id, salary, regexp_substr(name, '[0-9]+') as name  from emp_new;"
},
{
    "date": "02-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:35 PM",
    "body": "--How to create database link: it is a link that acts as bridge which allows one\n--database/user to access another database's tables.\n\nselect * from emp_new;\nselect * from emp_main;\nselect * from emp_master;\n\n--How to create user in DB:\ncreate user dbs9 identified by admin;\n--How to give session access to user in DB:\ngrant create session to dbs9;\n\n--To grant db link creation access to dbs9\ngrant create database link to dbs9;\nalter user dbs9 quota unlimited on users;\n\n--Now create database link in DBS9 to access the tables of DBS connection:\n--Steps to create a DB link between DBS and DBS9\n--Step 1: Connect to dbs9 and create the DB link\n\ncreate database link link_to_dbs8\nconnect to system --username of DBS connection\nidentified by DBS --password of DBS connection\nusing '(DESCRIPTION=\n(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521))\n(CONNECT_DATA=(SID=xe)))';  --connection details of DBS connection\n\n--Step 2: to check if db link is working or not:\nselect * from emp_main@link_to_dbs;\ndesc emp_main@link_to_dbs;\ninsert into emp_main@link_to_dbs values (110, 'Demo', 15000);\nupdate emp_main@link_to_dbs set name='Ronak' where id=110;"
},
{
    "date": "02-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:47 PM",
    "body": "--Special operator: REGEXP: it stands for Regular Expressions. It is used\n--to search, match, extract or replace text in a smarter way than normal like\n\n--LIKE: simple pattern matching\n--REGEXP: advanced pattern matching (numbers, letters, words, formats)\n\n--Types of REGEXP:\n--1. REGEXP_LIKE: used to check if a value matches a pattern. It is applied with where\n--clause to check if data matches a pattern or not.\n\nselect * from emp_new;\nupdate emp_new set name='Sunny Gupta' where id=102;\n\n--Eg: to find rows containing only numbers (can be applied to single table at a time)\nselect * from emp_new where regexp_like(name, '^[A-Za-z0-9]+$');\n\nselect * from emp_new where regexp_like(name, '[AB]', 'i'); -- to check for the records where name is having  A/B or a/b anywhere\nselect * from emp_new where regexp_like(name, '^[ab]', 'i'); -- to check the records where name is starting with a/b or A/B\n\n--REGEXP_REPLACE: it removes or replaces parts of text based on a pattern.\nselect regexp_replace(name, '[mi]', '') as result  from emp_new where id=108;\n \n--3. REGEXP_SUBSTR: is used to extract the certain part from the column data.\n--eg: to fetch only the last name from column data\nselect id, regexp_substr(name, '[^ ]+$') as last_name, salary from emp_new where id=102;\n\n--4. REGEXP_INSTR: to find position where a number/letter appears in the column data\nselect id, name, regexp_instr(name, '[0-9]') as letter_postion, salary from emp_new;\n\n--5. REGEXP_COUNT: is count how many times a pattern occurs\n--eg: count digits, letters and special characters in the name column:\nselect id, name, regexp_count(name,'[A-Za-z0-9]') as count, salary from emp_new;"
},
{
    "date": "03-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:37 PM",
    "body": "--Constraints in SQL: Rules apply on table columns to protect data and avoid mistakes.\n--They ensure that the data is unique, not missing and correctly linked between tables.\n\n--1. UNIQUE : to store the value in column which must be unique but can be null\ncreate table users\n(\nuser_id number,\nemail varchar2(300) unique\n);\n\ndesc users;\nselect * from users;\ninsert into users values (1, 'abc@gmail.com');\ninsert into users values (2, 'abcd@gmail.com');\ninsert into users values (3,null);\n--No two users can have the same email\n--Email can be NULL\n\n--2. NOT NULL: Column must have a value, it cannot be empty.\nalter table users modify user_id number not null;\ninsert into users values (null, 'abcdef@gmail.com');\n\n--3. PRIMARY KEY: A column that uniquely identifies each row:\n--Cannot be NULL\n--Cannot have duplicate values (Unique values only)\n--Combination of Unique + NOT NULL constraints\n\n--to declare existing column as primary key\nalter table users add constraint pk_users primary key (user_id);\n\n--to remove exisiting primaty key from table\nalter table users drop constraint SYS_C007075;\n\n--adding and new column and declaring it as primary key:\nalter table users add phone number(10);\nalter table users add constraint pk_phone primary key (phone);\ninsert into users values (6, 'abcui@gmail.com', 7748503253);\n\n--4. CHECK: Used to restrict allowed values. We define a define.\nselect * from users;\nalter table users add salary number;\nalter table users add constraint chk_salary check (salary>0);\n\nupdate users set status='Hired';\ninsert into users values (7, 'abcuid@gmail.com', 7748505853, 3000);\n\n--5. DEFAULT: If no value is entered, SQL will insert a default value automatically.\nalter table users add status  varchar2(100);\nselect * from users;\nalter table users modify status varchar2(100) default 'Pending';\ninsert into users (user_id, email, phone, salary, status) values\n(10, 'adbcdduidd@gmail.com', 8855505853, 6000, 'Hired');\n\n--6. COMPOSITE KEY: A primary key made of 2 or more columns together.\nalter table users add constraint ck_userid_phone primary key (user_id, phone);\n\n--Recap:\n--1. UNIQUE: No duplicate values.\n--2. NOT NULL: Cannot be empty.\n--3. PRIMARY KEY: Must be unique and not null (UNIQUE + NOT NULL)\n--4. CHECK: salary > 0\n--5. DEFAULT: If not given any value, then system will add automatically.\n--6. COMPOSITE KEY: to declare more than 1 column as PK."
},
{
    "date": "03-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:57 PM",
    "body": "--Constraints in SQL: Rules apply on table columns to protect data and avoid mistakes.\n--They ensure that the data is unique, not missing and correctly linked between tables.\n\n--1. UNIQUE : to store the value in column which must be unique but can be null\ncreate table users\n(\nuser_id number,\nemail varchar2(300) unique --> you can insert null values as well\n);\n\ndesc users;\nselect * from users;\n\ninsert into users values (1, 'abc@gmail.com');\ninsert into users values (2, 'abcd@gmail.com');\ninsert into users (user_id) values (4);\n\n--No two users can have the same email\n--Email can be NULL\n\n--2. NOT NULL: Column must have a value, it cannot be empty.\nalter table users modify user_id number not null;\ndesc users;\ninsert into users (user_id, email) values (7,'abcdeff@gmail.com');\n\n--3. PRIMARY KEY: A column that uniquely identifies each row:\n--Cannot be NULL\n--Cannot have duplicate values (Unique values only)\n--Combination of Unique + NOT NULL constraints\n\ndesc users;\n--to declare existing column as primary key\nalter table users add constraint pk_user_id primary key (user_id);\n\ninsert into users (user_id, email) values (8,'abcdefft@gmail.com');\ninsert into users (user_id,email) values (9,'abcdeffgg@gmail.com');\n\n--to remove exisiting primary key from table\nalter table users drop constraint pk_user_id;\n\n--adding and new column and declaring it as primary key:\nalter table users add phone number(10);\nalter table users add constraint pk_phone primary key (phone);\ninsert into users values (6, 'abcui@gmail.com', 7748503253);"
},
{
    "date": "04-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:35 PM",
    "body": "--6. FOREIGN KEY:\n--What is a Foreign Key?\n--A foreign key is a column (or set of columns) in one table that links to the primary key/unique key of another table.\n--This value must exist in that other table.\n--Purpose: To maintain relationships between tables and ensure referential integrity (no orphan records).\n--Table1: students:\nCREATE TABLE Students (\n    stu_id number PRIMARY KEY,  --column level constraint\n    name VARCHAR2(100)\n);\n\ndesc students;\n\n--Table 2 : enrollments:\nCREATE TABLE enrollments (\n    enroll_id number PRIMARY KEY, --column level\n    stu_id number,\n    course_name VARCHAR2(100),\n    CONSTRAINT fk_stud_course FOREIGN KEY (stu_id)\n        REFERENCES Students(stu_id) --table level columns\n);\n\ndesc enrollments;\n\n--stu_id in Enrollments is a foreign key.\n--It points to stu_id in Students.\n--This means you cannot insert an enrollment unless that stu_id already exists in the Students table.\n\nINSERT INTO Students VALUES (101, 'A');\nINSERT INTO Students VALUES (102, 'B');\nINSERT INTO Students VALUES (103, 'C');\nINSERT INTO Students VALUES (104, 'D');\n\nINSERT INTO Enrollments VALUES (1, 101, 'Python'); --inserted successfully.\nINSERT INTO Enrollments VALUES (2, 105, 'Java'); --integrity constraint voilated\n\nselect * from enrollments;\n\n--Why Disable/Enable Constraints?\n--Sometimes you want to:\n--Disable constraints ? temporarily stop checks (e.g., while bulk inserting data).\nALTER TABLE Enrollments disable CONSTRAINT FK_STUD_COURSE;\nINSERT INTO Enrollments VALUES (6, 106, 'Java');\n\n--Enable constraints ? turn them back on to enforce rules again.\nALTER TABLE Enrollments enable CONSTRAINT FK_STUD_COURSE;\n\n--Validating Constraints:\n--Enable the constraint without validating the existing data\nALTER TABLE Enrollments modify CONSTRAINT FK_STUD_COURSE\nENABLE NOVALIDATE;\n\n--Enable the constraint with validating the existing data\nALTER TABLE Enrollments modify CONSTRAINT FK_STUD_COURSE\nENABLE VALIDATE;\n\nINSERT INTO Enrollments VALUES (7, 107, 'Java');"
},
{
    "date": "04-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:33 PM",
    "body": "--Constraints:\n--4. CHECK: Used to restrict allowed values. We define a condition. \nselect * from users;\nupdate users set salary=10000;\nalter table users add salary number;\ndesc users;\n\ncreate table users\n(user_id number primary key, -- column level cons\nemail varchar2(100),\nsalary number check (salary >0),\nconstraint ck primary key(user_id, email)\n);\n\ndesc users;\n--adding a new column in table:\nalter table users add phone_no number;\n--applying check contraint on exisiting column\nalter table users add constraint chk_phone check (regexp_like(phone_no, '^[0-9]{10}$'));\nselect * from users;\ninsert into users values (12, 'abcsduiddfsdf@gmail.com',10000, 7485415215);\nalter table users add constraint chk_salary check (salary>=10000);\n\n--applying check contraint while creating table:\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0) -- check constraint\n);\n\n--5. DEFAULT: If no value is entered, SQL will insert a default value automatically.\nalter table users add status varchar2(100);\ndesc users;\n--applying default constraint on exiting column\nalter table users modify status varchar2(100) default 'Pending';\nselect * from users;\ninsert into users (user_id, email,salary, phone_no, status) values\n(14, 'adbcdsduhhidd@gmail.com',10000, 9955505853, 'Hired');\n\n--applying default contraint while creating table:\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0), -- check constraint\nstatus varchar2(50) default 'Pending' -- default constraint\n);\n\n--6. COMPOSITE KEY: A primary key made of 2 or more columns together.\n--dropping the exisiting primary key:\nalter table users drop constraint PK_USERID;\n--creating a composite key for two columns on existing table\nalter table users add constraint ck_userid_email primary key (user_id, email);\n--applying composite key contraint while creating table:\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0), -- check constraint\nstatus varchaar2(50) default 'Pending', -- default constraint\nconstraint com_key primary key(user_id, email) --composite key\n);\n\n--Column level and Table level constraints:\n--Column level constraint: applied on single column\n--Table level constraint: applied on multiple columns\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0), -- check constraint -- column level constraint\nstatus varchaar2(50) default 'Pending', -- default constraint  -- column level constraint\nconstraint com_key primary key(user_id, email) --composite key -- table level constraint\n);\n\n--Naming conventions:\n--name given to constraints while defining it.\nalter table users add constraint ck_userid_email primary key (user_id, email);\n--ck_user_id_email -- name of the constraint"
},
{
    "date": "05-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:08 PM",
    "body": "--Joins in SQL:  is used to combine data from two tables based on a related column.\n--1. Inner Join: shows only matching rows from both tables.\n\ncreate table students\n(\nroll_no number,\nname varchar2(100)\n);\n\ncreate table marks\n(\nroll_no number,\nmarks number\n);\ndesc students;\n\ninsert into students values (1,'Rahul');\ninsert into students values (2,'Ram');\ninsert into students values (3,'Aman');\ninsert into students values (4,'Rohan');\n\nselect * from students;\n\ninsert into marks values (1,90);\ninsert into marks values (2,65);\ninsert into marks values (5,75);\n\nselect s.roll_no, s.name, m.marks\nfrom students s\ninner join marks m\non s.roll_no=m.roll_no;\n\n--2. Left Join (Left Outer Join): shows all rows from left table and matching rows\n--from right table\nselect * from marks;\n\nselect students.roll_no, students.name, marks.marks\nfrom students \nleft join marks \non students.roll_no=marks.roll_no;\n\n--3. Right Join (Right Outer Join): shows all rows from right table and matching \n--rows from left table:\n\nselect students.roll_no, students.name, marks.marks\nfrom students \nright join marks \non students.roll_no=marks.roll_no;\n\n--4. Full Outer Join: shows all rows from both tables, matching or not.\n\nselect s.roll_no, s.name, m.marks\nfrom students s\nfull join marks m\non s.roll_no=m.roll_no;\n\n--5. Cross Join: makes every combination of rows from both tables.\n--students - 4 rows\n--marks - 3 rows\n--output - 12 rows\n\nselect * from students cross join marks;\n\n--6. Self Join: A table joins with itself\n\nselect s.roll_no, s.name as studentName_first, s1.name as studentName_second\nfrom students s\njoin students s1\non s.roll_no=s1.roll_no;\n\n--Recap:\n--Inner - only matching rows\n--Left - All left + matching right\n--Right - All right + matching left\n--Full - All rows from both\n--Cross - Every combination (cartesian product)\n--Self - Table joins itself"
},
{
    "date": "05-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:22 PM",
    "body": "--Constraints:\n--PRIMARY KEY: Not Null + Unique\nselect * from students;\nalter table students add constraint pk_roll_no primary key (roll_no);\ninsert into students values (4,'Shyam');\ndesc students;\n\n--6. FOREIGN KEY:\n--What is a Foreign Key?\n--A foreign key is a column (or set of columns) in one table that links to the primary key/unique key of another table.\n--This value must exist in that other table.\n--Purpose: To maintain relationships between tables and ensure referential integrity (no orphan records).\n--Table1: students:\nCREATE TABLE Students (\n    roll_no number PRIMARY KEY,  --column level constraint\n    name VARCHAR2(100)\n);\n\n\ndesc students;\n\n--Table 2 : enrollments:\nCREATE TABLE enrollments (\n    enroll_id number PRIMARY KEY, --column level\n    roll_no number,\n    course_name VARCHAR2(100),\n    CONSTRAINT fk_rollNo FOREIGN KEY (roll_no)\n        REFERENCES Students(roll_no) --table level columns\n);\n\n\ndesc enrollments;\n--enrollments:\n--roll_no in Enrollments is a foreign key.\n--It points to roll_no in Students.\n--This means you cannot insert an enrollment unless that roll_no already exists in the Students table.\n\nINSERT INTO Students VALUES (101, 'A');\nINSERT INTO Students VALUES (102, 'B');\nINSERT INTO Students VALUES (103, 'C');\nINSERT INTO Students VALUES (104, 'D');\n\nselect * from students;\n\nselect * from enrollments;\n\nINSERT INTO Enrollments VALUES (4, 102, 'Python'); --inserted successfully.\nINSERT INTO Enrollments VALUES (2, 105, 'Java'); --integrity constraint voilated\n\nselect * from enrollments;\n\n--Why Disable/Enable Constraints?\n--Sometimes you want to:\n--Disable constraints ? temporarily stop checks\nALTER TABLE Enrollments disable CONSTRAINT FK_ROLLNO;\n--Enable constraints ? turn them back on to enforce rules again.\nALTER TABLE Enrollments enable CONSTRAINT FK_ROLLNO;\n\n--Validating Constraints:\n--Enable the constraint without validating the existing data\nALTER TABLE Enrollments modify CONSTRAINT FK_ROLLNO\nENABLE NOVALIDATE;\n\n--Enable the constraint with validating the existing data\nALTER TABLE Enrollments modify CONSTRAINT FK_ROLLNO\nENABLE VALIDATE;\n\n--to permannently drop the contraint:\nalter table enrollments drop CONSTRAINT SYS_C007105;\n\n--to make any existing columns as primary key\nalter table enrollments add constraint pk_enroll_id primary key (enroll_id);"
},
{
    "date": "06-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "03:21 PM",
    "body": "--Joins in SQL:  is used to combine data from two tables based on a related column.\n--1. Inner Join: shows only matching rows from both tables.\n\ncreate table students\n(\nroll_no number,\nname varchar2(100)\n);\n\ncreate table marks\n(\nroll_no number,\nmarks number\n);\ndesc students;\n\ninsert into students values (1,'Rahul');\ninsert into students values (2,'Ram');\ninsert into students values (3,'Aman');\ninsert into students values (4,'Rohan');\n\nselect * from marks;\nupdate marks set roll_no=101 where roll_no=1;\ninsert into marks values (1,90);\ninsert into marks values (2,65);\ninsert into marks values (5,75);\n\nselect s.roll_no, s.name, m.marks\nfrom students s\ninner join marks m\non s.roll_no=m.roll_no;\n\n--2. Left Join (Left Outer Join): shows all rows from left table and matching rows\n--from right table\nselect * from marks;\n\nselect s.roll_no, s.name, m.marks\nfrom students s\nleft join marks m\non s.roll_no=m.roll_no;\n\n--3. Right Join (Right Outer Join): shows all rows from right table and matching\n--rows from left table:\n\nselect students.roll_no, students.name, marks.marks\nfrom marks\nright join students\non students.roll_no=marks.roll_no;\n\n--4. Full Outer Join: shows all rows from both tables, matching or not.\n\nselect s.roll_no, s.name, m.marks\nfrom students s\nfull join marks m\non s.roll_no=m.roll_no;\n\n--5. Cross Join: makes every combination of rows from both tables.\n--students - 4 rows\n--marks - 3 rows\n--output - 12 rows\n\nselect * from students cross join marks;\n\n--6. Self Join: A table joins with itself\nselect * from students;\nselect s.roll_no, s.name as studentName_first, s1.name as studentName_second\nfrom students s\njoin students s1\non s.name=s1.name;\n\ncreate table emp;\n\nselect * from emp;\nalter table emp add manager_id number;\n\nupdate emp set manager_id=10 where emp_id=2;\n\nselect e.emp_name as manager,\nm.emp_name as emp\nfrom emp e\njoin emp m\non e.manager_id=m.emp_id;\nselect * from emp;\n\n--every org uses self join to check who reports to whom\n\n--Natural Join: joins automatically using columns with the same name in both tables;\nselect * from students natural join marks;\n\n--equi join: join using equality = condition\nselect s.roll_no, s.name, m.marks\nfrom students s\ninner join marks m\non s.roll_no=m.roll_no;\n\n--Natural Join --> automatic join\n--Equi Join --> manual join using ="
},
{
    "date": "06-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "09:20 PM",
  "body": "--Joins in SQL:  is used to combine data from two tables based on a related column.\n--1. Inner Join: shows only matching rows from both tables.\n\ncreate table students\n(\nroll_no number,\nname varchar2(100)\n);\n\ncreate table marks\n(\nroll_no number,\nmarks number\n);\n\ndesc marks;\n\ninsert into students values (1,'Rahul');\ninsert into students values (2,'Ram');\ninsert into students values (3,'Aman');\ninsert into students values (4,'Rohan');\n\nselect * from marks;\n\ninsert into marks values (1,90);\ninsert into marks values (2,65);\ninsert into marks values (5,75);\n\nselect s.roll_no, s.name, m.marks\nfrom students s\ninner join marks m\non s.roll_no=m.roll_no;\n\n--2. Left Join (Left Outer Join): shows all rows from left table and matching rows\n--from right table\nselect * from marks;\n\nselect students.roll_no, students.name, marks.marks\nfrom students left join marks \non students.roll_no=marks.roll_no;\n\n--3. Right Join (Right Outer Join): shows all rows from right table and matching \n--rows from left table:\n\nselect students.roll_no, students.name, marks.marks\nfrom students right join marks \non students.roll_no=marks.roll_no;\n\n--4. Full Outer Join: shows all rows from both tables, matching or not.\n\nselect s.roll_no, s.name, m.marks\nfrom students s\nfull join marks m\non s.roll_no= m.roll_no;\n\n--Recap:\n--Inner - only matching rows\n--Left - All left + matching right\n--Right - All right + matching left\n--Full - All rows from both\n"
},
{
    "date": "08-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:17 PM",
  "body":  "--Joins in SQL:  is used to combine data from two tables based on a related column.\n--1. Inner Join: shows only matching rows from both tables.\n\ncreate table students\n(\nroll_no number,\nname varchar2(100)\n);\n\ncreate table marks\n(\nroll_no number,\nmarks number\n);\ndesc students;\n\n\nselect * from marks;\ninsert into students values (1,'Rahul');\ninsert into students values (2,'Ram');\ninsert into students values (3,'Aman');\ninsert into students values (4,'Rohan');\n\nselect * from students;\n\ninsert into marks values (1,90);\ninsert into marks values (2,65);\ninsert into marks values (5,75);\n\nselect s.roll_no, s.name, m.marks\nfrom students s\ninner join marks m\non s.roll_no=m.roll_no;\n\n--2. Left Join (Left Outer Join): shows all rows from left table and matching rows\n--from right table\nselect * from marks;\n\nselect students.roll_no, students.name, marks.marks\nfrom students left join marks\non students.roll_no=marks.roll_no;\n\n--3. Right Join (Right Outer Join): shows all rows from right table and matching\n--rows from left table:\n\nselect students.roll_no, students.name, marks.marks\nfrom marks right join students\non students.roll_no=marks.roll_no;\n\n--4. Full Outer Join: shows all rows from both tables, matching or not.\n\nselect s.roll_no, s.name, m.marks\nfrom students s full join marks m\non s.roll_no=m.roll_no;\n\n--5. Cross Join: makes every combination of rows from both tables.\n--students - 4 rows\n--marks - 3 rows\n--output - 12 rows\n\nselect * from students cross join marks;\n\n--6. Self Join: A table joins with itself\n\nselect * from emp;\n\nalter table emp  add manager_id number;\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(106,'Ram',40000,null);\n\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(107,'Raman',45000,null);\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(108,'MOhan',46000,null);\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(109,'Aman',41000,null);\n\nupdate emp set manager_id=107 where emp_id=109;\n\n\nselect e.name as employee,\nm.name as manager\nfrom emp e join emp m\non e.emp_id= m.manager_id;\n\n\n--Recap:\n--Inner - only matching rows\n--Left - All left + matching right\n--Right - All right + matching left\n--Full - All rows from both\n--Cross - Every combination (cartesian product)\n--Self - Table joins itself\n--Natural Join:  automatic join\nselect * from students natural join marks;\n--Equi Join --> manual join using ="
},
{
    "date": "08-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "11:00 PM",
  "body":  "--Joins in SQL:  is used to combine data from two tables based on a related column.\n--1. Inner Join: shows only matching rows from both tables.\n\ncreate table students\n(\nroll_no number,\nname varchar2(100)\n);\n\ncreate table marks\n(\nroll_no number,\nmarks number\n);\ndesc students;\n\n\nselect * from marks;\ninsert into students values (1,'Rahul');\ninsert into students values (2,'Ram');\ninsert into students values (3,'Aman');\ninsert into students values (4,'Rohan');\n\nselect * from students;\n\ninsert into marks values (1,90);\ninsert into marks values (2,65);\ninsert into marks values (5,75);\n\nselect s.roll_no, s.name, s.phone, m.marks\nfrom students s\ninner join marks m\non s.roll_no=m.roll_no;\n\n--2. Left Join (Left Outer Join): shows all rows from left table and matching rows\n--from right table\nselect * from students;\n\nselect students.roll_no, students.name, marks.marks\nfrom students left outer join marks \non students.roll_no=marks.roll_no;\n\nalter table students add phone number;\n\n--3. Right Join (Right Outer Join): shows all rows from right table and matching \n--rows from left table:\n\nselect students.roll_no, students.name, marks.marks\nfrom marks right outer join students\non students.roll_no=marks.roll_no;\n\nselect * from students;\n\n--4. Full Outer Join: shows all rows from both tables, matching or not.\n\nselect s.roll_no, s.name, m.marks\nfrom students s full join marks m\non s.roll_no=m.roll_no;\n\nselect * from students s full outer join marks m on s.roll_no=m.roll_no;\n\n--5. Cross Join: makes every combination of rows from both tables.\n--students - 4 rows\n--marks - 3 rows\n--output - 12 rows\n\ne-comm:  T shirt (S, M, L, XL)\ncolor: (Red, blue, yellow, white)\n\nselect * from students cross join marks;\n\n--6. Self Join: A table joins with itself\n\nselect * from emp;\n\nalter table emp  add manager_id number;\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(106,'Ram',40000,null);\n\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(107,'Raman',45000,null);\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(108,'MOhan',46000,null);\nInsert into emp (EMP_ID,NAME,SALARY,MANAGER_ID) values\n(109,'Aman',41000,null);\n\nupdate emp set manager_id=107 where emp_id=109;\n\nselect * from emp;\n\nselect e.name as employee,\nm.name as manager\nfrom emp e join emp m\non e.emp_id= m.manager_id;\ndesc emp;\nselect * from emp;\n--Recap:\n--Inner - only matching rows\n--Left - All left + matching right\n--Right - All right + matching left\n--Full - All rows from both\n--Cross - Every combination (cartesian product)\n--Self - Table joins itself\n--Natural Join:  automatic join\nselect * from students natural join marks;\n--Equi Join --> manual join using =\n\n--Foreign Key:\nselect * from customers;\n\nselect * from orders;\n\nalter table orders drop constraint FK_ORDERS_CUSTOMER;\n\nalter table orders add constraint fk_customer_id foreign key (customer_id)\nreferences customers(customer_id);\n\ninsert into orders values (107, 3, sysdate);"
},
{
    "date": "09-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "03:20 PM",
  "body":  "--FUNCTIONS IN SQL : Function is used to perform specific task \n        \n--   1.  Pre defined functions :  All SQL functions are pre - defined functions.\n--   2.  User Defined Functions : Created or defined by user based on requirement\n\n--   1.  Pre defined functions : Its of two types:\n--  a. Single row functions: work on one row at a time.\n--    Types: 1. Char functions:\n--    1.1 UPPER(): to convert char data in upper case\n    select upper('sql') from dual;\n    select upper(name), e.*  from emp e;\n--    1.2 LOWER(): to convert char data in lower case\n    select lower('SQL') from dual;\n    select lower(name),  emp_id, salary, manager_id from emp ;\n--    1.3 SUBSTR(): to fetch the substring from original string\n    select substr('Oracle', 1,3) from dual;\n    select emp_id, name,substr(name,1,3), salary, manager_id from emp;\n--    1.4 LENGTH(): to find the length of char data\n    select length('Hello World') from dual;\n    select emp_id, name,length(name), salary, manager_id from emp;\n     \n--  Types: 2. Number functions:     \n--2.1. round(): select round(15.6789, 2) from dual;\nselect emp_id, name, salary, round(salary, 2), manager_id from emp;\n\n--2.2. trunc(): select trunc(15.6789,1) from dual;\nselect emp_id, name, salary, trunc(salary, 1), manager_id\nfrom emp;\n\n--2.3. mod(): select mod(10,3) from dual;\nselect mod(emp_id,2), name, salary, manager_id\nfrom emp;\n--odd or even emp records\nselect * from emp where mod(emp_id,2)=1;\n\nselect * from emp;\ngrant insert, select ;\n\ndrop table clone;\ncreate table clone as select * from employee;\nupdate emp set salary = 40000.1245 where emp_id=102;\n\nselect dbms_metadata.get_ddl('TABLE','EMPLOYEE') from dual;\n\nSELECT * FROM CLONE;\n\nINSERT INTO CLONE SELECT * FROM EMPLOYEE;\n\n\n  CREATE TABLE \"SYSTEM\".\"CLONE\" \n   (    \"EMP_ID\" NUMBER, \n    \"EMP_NAME\" VARCHAR2(50), \n    \"DEPT_ID\" NUMBER, \n     PRIMARY KEY (\"EMP_ID\")\n  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS \n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"SYSTEM\"  ENABLE, \n     CONSTRAINT \"FK_DEPT_CLONE\" FOREIGN KEY (\"DEPT_ID\")\n      REFERENCES \"SYSTEM\".\"DEPARTMENT\" (\"DEPT_ID\") ENABLE\n   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING\n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"SYSTEM\" \n\n  CREATE TABLE \"SYSTEM\".\"CLONE\" \n   (    \"EMP_ID\" NUMBER, \n    \"EMP_NAME\" VARCHAR2(50), \n    \"DEPT_ID\" NUMBER, \n     PRIMARY KEY (\"EMP_ID\")\n  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS \n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"SYSTEM\"  ENABLE, \n     CONSTRAINT \"FK_DEPT_CLONE\" FOREIGN KEY (\"DEPT_ID\")\n      REFERENCES \"SYSTEM\".\"DEPARTMENT\" (\"DEPT_ID\") ENABLE\n   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING\n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"SYSTEM\";"
},
{
    "date": "09-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "09:16 PM",
  "body":  "--FUNCTIONS IN SQL : Function is used to perform specific task \n        \n--   1.  Pre defined functions :  All SQL functions are pre - defined functions.\n--   2.  User Defined Functions : Created or defined by user based on requirement\n\n--   1.  Pre defined functions : Its of two types:\n--  a. Single row functions: work on one row at a time.\n--    Types: 1. Char functions:\n--    1.1 UPPER(): to convert char data in upper case\n    select upper('sql') from dual;\n    select upper(name), emp_id, salary, manager_id  from emp ;\n    select * from emp ;\n    \n--    1.2 LOWER(): to convert char data in lower case \n    select lower('SQL') from dual;\n    select emp_id, lower(name) Name, salary, manager_id from emp ;\n    \n--    1.3 SUBSTR(): to fetch the substring from original string\n    select substr('Hello World', 1, 8) from dual;\n    select emp_id, name,substr(name,1,3), salary, manager_id from emp;\n    \n--    1.4 LENGTH(): to find the length of char data\n    select length('Hello World') from dual;\n    select emp_id, name,length(name), salary, manager_id from emp;\n    alter table emp add mobile_no number;\n    \n    select * from emp where length(mobile_no) <> 10;\n\n--  Types: 2. Number functions:     \n--2.1. round():\nselect round(15.6789, 2) from dual;\nselect trunc(15.6789,2) from dual;\nselect emp_id, name, salary, round(salary, 2), manager_id from emp;\n\n--2.2. trunc(): \nselect trunc(15.6789,2) from dual;\nselect emp_id, name, salary, trunc(salary, 2), manager_id\nfrom emp;\n\n--2.3. mod(): \n\nselect * from emp;\n\nselect mod(10,3) from dual;\n--even: emp_id/2=0 (even)\n--odd: emp_id/2=1 (odd)\n--odd or even emp records\nselect * from emp where mod(emp_id,2)=1;\n\n--Type 3: Date functions:\n-- 3.1: sysdate: current date\nselect sysdate from dual;\n\n-- 3.2: add_months(): to add to show previous months for the given date\n\nselect add_months('09-12-25', +1) from dual;\n\n-- 3.3: months_between(): to find the months between the given dates\nselect months_between('01-JAN-2026', '01-JAN-2025') from dual;\n\n--Type:4 Conversion functions:\n--4.1: to_char(date):\nselect sysdate from dual; 09-DEC-2025\nselect to_char(sysdate, 'DD-MON-YYYY') from dual; '09-DEC-2025'\n\n--4.2: to_date():\nselect to_date('25-DEC-2025', 'DD-MON-YYYY') from dual;\n\n--4.3: to_number()\nselect to_number('123') from dual;"
},
{
    "date": "10-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:52 PM",
  "body":  "--   1.  Pre defined functions : a. SIngle row functions:\n--Type 3: Date functions:\n-- 3.1: sysdate: current date\nselect sysdate from dual;\n\nselect * from emp;\nalter table emp add hire_date date;\nupdate emp set hire_date=sysdate where emp_id=102;\n\n-- 3.2: add_months(): to add to show previous months for the given date\nselect add_months(sysdate, +2) from dual;\n\n-- 3.3: months_between(): to find the months between the given dates\nselect months_between('01-JAN-2026', '01-FEB-2025') from dual;\n\n--Type:4 Conversion functions:\n--4.1: to_char(date):\nselect sysdate from dual; 10-DEC-2025\nselect to_char(sysdate, 'DD-MON-YYYY') from dual; '10-DEC-2025'\n\n--4.2: to_date():\nselect to_date('25-DEC-2025', 'DD-MON-YYYY') from dual; 25-DEC-2025\n\n--4.3: to_number()\nselect to_number('123') from dual; \n\n\n--Table and Column comment:\n\n--1. Comment on Table- adds description for entire table:\nselect * from emp;\ncomment on table emp is 'This table is storing emp details';\nselect * from user_tab_comments where table_name ='EMP';\n\n--2. Comment on Column- adds description for a specific column\nselect * from emp;\ncomment on column emp.manager_id is 'It will store emp_id of reporting emp';\nselect * from user_col_comments where table_name ='EMP';\n\n--  b. Aggregate functions: GROUP FUNCTIONS / AGGREGATE FUNCTIONS :\n        \n    --    Group functions are acting on group of values and generating result as single value.\n        \n        --1) MIN : to find minimum value\n            select * from emp;\n            select min(salary) from emp;\n            select * from emp where salary= (select min(salary) from emp);\n            \n        \n      --  2) MAX : to find maximum value\n           \n            select max(salary) from emp;\n            select * from emp where salary= (select max(salary) from emp);\n        \n       -- 3) AVG : to find average value\n        \n                select avg(salary) from emp;\n        \n      --  4) SUM : is used to add the column values\n        \n                    select sum(salary) from emp;\n                    \n       -- 5) COUNT : to count number of rows\n                   \n                   select count(manager_id) from emp;\n                   select count(*) from emp;\n        \n        --to find the 3rd highest salary from emp table\n        select * from emp where salary= \n        (select max(salary) from emp where \n        salary < (select max(salary) from emp where \n        salary < (select max(salary) from emp)));\n        \n--        General Functions: this functions works on any datatype (number, char, date)\n--        and return one row per input row.\n\n--Types: \n--1. NVL(): Replaces NULL with a given value.\n--2. NVL2(): If exp1 is not null --> return exp2, if exp1 is null --> return exp3\n--3. NULLIF(): Returns NULL if exp1=exp2 otherwise returns exp1\n--4. COALESCE()\n--5. GREATEST()\n--6. LEAST()\n\n--1. NVL(): Replaces NULL with a given value.\nselect emp_id, name, salary, manager_id, nvl(manager_id, 0) from emp;\n\n--2. NVL2: NVL2(exp1, exp2, exp3):\nIf exp1 is not null --> return exp2\nif exp1 is null --> return exp3\n\nselect emp_id, name, salary, manager_id, nvl2(incentive, 'Incentive Earned', 'No Incentive') from emp;\nselect * from emp;\n\nselect e.*,case when salary < 45000 then null\nelse salary \nend \nfrom emp e;\n\nselect * from emp;\n\nalter table emp modify incentive number;\n\nupdate emp set incentive =4000 where emp_id=109;\n\n--3 NULLIF(exp1, emp2): Returns NULL if exp1=exp2 otherwise returns exp1\n\nselect emp_id, name, salary, manager_id, nullif(salary, 35000) from emp ;"
},
{
    "date": "10-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "08:57 PM",
  "body":  "--Primary Key: It is a column (set of columns) that uniquely identifes each row\n--in a table.\n\n--Conditions: 1. It cannot be NULL\n--2. It must be unique\n--3. One table can have only one primary key column\n\n--Example:\n--1. UIDAI: AAdhar Number: Primary Key\n\nselect * from customers;\ndesc customers;\n\nalter table customers drop constraint PK_PHONE_NO;\n\nalter table customers add phone_no number(10);\n\n\nalter table customers add constraint pk_phone_no primary key ( customer_id)\nenable NOVALIDATE;\n\n\ndesc cust;\ncreate table cust\n(\ncust_id number primary key,\ncust_name varchar2(100),\nphone number(10)\n);\n\nselect * from customers;\n\ninsert into customers values (8, 'Rohit',7748526345); \n\nalter table customers modify phone_no number(10)\ncheck (regexp_like(phone_no, '^[0-9]{10}$'));\n\n--Foreign Key: \n--First table: Customers:\nselect * from customers;\n--Parent Table: Primary/Unique Key column\n--Second Table: Bank Details:\nChild Table: that will always refers to parent primary/unique column through FK\ncreate table bank_acc\n(\nacc_no number,\ncustomer_id number,\nbalance number,\nconstraint fk_customer_id foreign key (customer_id) \nreferences customers(customer_id)\n);\n\nselect * from customers;\nselect * from  bank_acc;\ninsert into bank_acc values (4152441,4, 5000); \n\n--COaching:\n--students(stu_id, name)\n--course_enroll (stu_id, course)"
},
{
    "date": "11-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "04:05 PM",
  "body":  "--        General Functions: this functions works on any datatype (number, char, date)\n--        and return one row per input row.\n\n--Types: \n--1. NVL(exp1, exp2): Replaces NULL with a given value.\n--2. NVL2(): If exp1 is not null --> return exp2, if exp1 is null --> return exp3\n--3. NULLIF(): Returns NULL if exp1=exp2 otherwise returns exp1\n--4. COALESCE()\n--5. GREATEST()\n--6. LEAST()\n\n--1. NVL(): Replaces NULL with a given value.\nselect emp_id, name, salary, manager_id, nvl(manager_id, 1) from emp;\n\nselect * from emp;\n\n--2. NVL2: NVL2(exp1, exp2, exp3):\nIf exp1 is not null --> return exp2\nif exp1 is null --> return exp3\n\nselect emp_id, name, salary, manager_id, incentive,nvl2(incentive, 'Incentive Earned', 'No Incentive') from emp;\nselect * from emp;\n\nselect e.*,case when salary < 45000 then null\nelse salary \nend \nfrom emp e;\n\nselect * from emp;\n\nalter table emp modify incentive number;\n\nupdate emp set incentive =4000 where emp_id=109;\n\n--3 NULLIF(exp1, emp2): Returns NULL if exp1=exp2 otherwise returns exp1\n\nselect emp_id, name,  manager_id,salary ,nullif(salary, 35000) from emp ;\n\n--4. COALESCE(exp1, exp2, exp3, .....): returns the first non-null value from the list.\n\nselect coalesce(NULL, null, sysdate) from dual;\n\n--5. Greatest: Largest value/ it will adjust the lesser column values with the given value.\n\nselect greatest(10,20,5) from dual;\n\nselect  emp_id, name, salary, greatest(salary, 41000) from emp;\n\n--6. LEAST(): returns the smallest value.\n\nselect least(10,5,30) from dual;\n\nselect emp_id, name, salary, least(salary, 41000) from emp;\n\n--6. DECODE(): works like IF-ELSE/CASE statement:\nselect * from emp;\n\nalter table emp add dept_no number;\n\nupdate emp set dept_no=10 where emp_id=102;\nupdate emp set dept_no=20 where emp_id=104;\nupdate emp set dept_no=10 where emp_id=105;\nupdate emp set dept_no=30 where emp_id=106;\nupdate emp set dept_no=20 where emp_id=107;\nupdate emp set dept_no=30 where emp_id=108;\n--gender: M or F\n--10-- Account\n--20-- HR\n--30-- Sales\nselect emp_id, name, status,dept_no, decode(dept_no, \n10, 'Male', \n20, 'HR',\n30, 'Sales',\n'Unknown') as status from emp;\n\n--8. CASE Expression: Modern version of DECODE.\n\n\nselect emp_id, name, salary,status,\ncase\nwhen status = 'A' then 'Active'\nwhen status= 'I' then 'Inactive'\nelse 'Unknown'\nend as Status\nfrom emp;\n\n--General Functions:\n--1. NVL: replace NULL with a value.\n--2. NVL2: Return value based on NULL/Not NULL\n--3. NULLIF: Returns NULL if both inputs match\n--4. COALESCE: First non-null value\n--5. Greatest: Largest value/ it will adjust the lesser column values with the given value.\n--6. LEAST: Smallest value/ it will adjust the larger column values with the given value.\n--7. DECODE: if-else logic\n--8. CASE: Alternative of Decode or advanced conditional logic\n\n--DROP, TRUNCATE: DDL (Auto committed)\n--DELETE: DML (Not auto committed)\n\nalter table emp add constraint ck_empid_mob \nprimary key (emp_id, mobile_No);\n\nalter table emp drop constraint CK_EMPID_MOB;\n\nalter table emp rename constraint CK_EMPID_MOB to CK_emp_id_mobile_no;"
},
{
    "date": "11-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "10:34 PM",
  "body":   "--Joins in SQL:  is used to combine data from two tables based on a related column.\n--1. Inner Join: shows only matching rows from both tables.\nselect * from marks;\ncreate table students\n(\nroll_no number,\nname varchar2(100)\n);\n\ncreate table marks\n(\nroll_no number,\nmarks number\n);\ndesc marks;\n\ninsert into students values (1,'Rahul');\ninsert into students values (2,'Ram');\ninsert into students values (3,'Aman');\ninsert into students values (4,'Rohan');\n\nselect * from students;\n\ninsert into marks values (1,90);\ninsert into marks values (2,65);\ninsert into marks values (5,75);\n\nselect s.roll_no, s.name, m.marks\nfrom students s inner join marks m\non s.roll_no=m.roll_no;\n\nselect * from students s inner join marks m on s.roll_no=m.roll_no;\n\n--2. Left Join (Left Outer Join): shows all rows from left table and matching rows\n--from right table\nselect * from marks;\n\nselect s.roll_no, s.name, m.marks\nfrom students s left outer join marks m \non s.roll_no=m.roll_no;\n\nselect * from students s left join marks m on s.roll_no=m.roll_no;;\n\n--3. Right Join (Right Outer Join): shows all rows from right table and matching \n--rows from left table:\n\nselect students.roll_no, students.name, marks.marks\nfrom marks right outer join students \non students.roll_no=marks.roll_no;\n\n--4. Full Outer Join: shows all rows from both tables, matching or not.\n\nselect *\nfrom students s full outer join marks m\non s.roll_no=m.roll_no;\n\n--5. Cross Join: makes every combination of rows from both tables.\n--students - 4 rows\n--marks - 3 rows\n--output - 12 rows\n\necomm-\nT shirt\nt shirt: t_size\nS\nM\nL \nXL\nXXL\n\nt_color:\nRed, Blue, White, Green, Yellow\n\nselect * from students cross join marks;\n\n--6. Self Join: A table joins with itself\n\nEmp --> Manager relationship\nselect * from emp;\n\nselect e.name as Employee,\nm.name as Manager\nfrom emp e join emp m\non e.emp_id=m.manager_id;\n\nselect emp_id, name, salary, manager_id from emp;\n\n\n--Recap:\n--Inner - only matching rows\n--Left - All left + matching right\n--Right - All right + matching left\n--Full - All rows from both\n--Cross - Every combination (cartesian product)\n--Self - Table joins itself\n\n--Auxillary joins:\n--Natural Join: automatic join, it will give you result similar to inner join\nselect * from students natural join marks;\n--Equi Join: is used to perform manual matching with the help of on and = operators.\n\n\n\n\ncreate table t_size\n(\nt_size varchar2(10)\n);\n\n\ncreate table t_color\n(\n--t_size varchar2(10),\nt_color varchar2(50)\n\n);\nselect * from t_size;\nselect * from t_color;\ninsert into t_color values ('Yellow');\n\ndrop table t_color;\n\nselect * from t_size cross join t_color;"
},
{
    "date": "12-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "04:19 PM",
  "body":   "--Multi row functions:\n--Aggregate functions: sum, min, max, count, avg\n--Group by clause\n--Having clause\n\n--Group by clause: is used to group rows that have the same values in one or more\n--columns and then we apply aggegate functions on each group.\n\ndesc sales;\ncreate table sales\n(\nproduct varchar2(100),\namount number,\ncity varchar2(100)\n);\n\n\ninsert into sales  values ('Mobile', 12000, 'Pune');\ninsert into sales values ('Laptop', 40000, 'Pune');\ninsert into sales values ('Mobile', 15000, 'Mumbai');\ninsert into sales values ('Laptop', 35000, 'Mumbai');\n\nselect * from sales;\n\n\nselect product, sum(amount) as total_sales from sales group by product;\n\n--Here we have grouped all 'Mobile' together and all 'Laptop' together.\n\n--Eg: to check how many employees work in different departments:\nselect * from employees;\n\nalter table employees add dept varchar2(10);\n\nupdate employees set salary =10000;\ndelete from employees;\n\n\ninsert into employees values (1, 'Raj',10000, 'HR');\ninsert into employees values (2, 'Asha',25000, 'IT');\ninsert into employees values (3, 'Zoya',60000, 'HR');\ninsert into employees values (4, 'Amit',28000, 'IT');\ninsert into employees values (5, 'Aman',55000, 'HR');\n--Number of employees in each department:\n--HR, IT\nselect dept, count(*) as total_employees from employees group by dept; \n\n--total salary paid in each department\nselect dept, avg(salary) as total_salary from employees group by dept;\n\n\n--website visitors:\n\n--website_log\n\n\n-- HAVING Clause: it works like where but it is used for filtering groups, \n--not individual rows\n\n--where -> filters rows\n--having --> filters groups (after grouping)\n\n\nselect * from sales;\n\n--show only cities where total_sales > 50000\nselect city, sum(amount) as total_sales from sales group by\ncity having sum(amount) > 50000;\n\n--departments with avg salary > 40000;\nselect dept, avg(salary) as avg_salary from employees\ngroup by dept having avg(salary) > 40000;\n\n--ecomm--\nselect * from  orders;\ndelete from orders;\n\ndesc orders;\n\nalter table orders add product varchar2(100);\n\ninsert into orders values (1, sysdate-2, 'Raj', 'Mobile');\ninsert into orders values (2, sysdate-3, 'Raj', 'Laptop');\ninsert into orders values (3, sysdate-4, 'Aman', 'Mobile');\ninsert into orders values (4, sysdate, 'Rahul', 'Mobile');\ninsert into orders values (5, sysdate-2, 'Aman', 'Laptop');\ninsert into orders values (6, sysdate-3, 'Rahul', 'Mobile');\ninsert into orders values (7, sysdate-6, 'Raj', 'TV');\nselect * from orders;\n\n\n--customers who has placed more than 1 order:\n\nselect customer_name, count(*) as total_orders from orders\ngroup by customer_name having count(*) > 1;\n\n\n--Subquery: When a query is used inside a query then its called as sub-query or nested query.\n--1. Single-row Subquery: returns only one row and one column as output. It is \n--used with comparison operators, like : =, <, >, <=, >=, !=\nselect * from employees;\n\n\n--Find employees earning more than the average salary:\nselect emp_name, salary from employees where salary > (select avg(salary) from employees);\n\n--select avg(salary) from employees: return one value --> avg salary\n--main query select all employees earning more than this value.\n\n\nselect * from orders;\n\nalter table orders add amount number;\n\nupdate orders set amount = 10000 where order_id=1;\nupdate orders set amount = 12000 where order_id=2;\nupdate orders set amount = 14000 where order_id=3;\nupdate orders set amount = 20000 where order_id=4;\nupdate orders set amount = 25000 where order_id=5;\nupdate orders set amount = 40000 where order_id=6;\nupdate orders set amount = 62000 where order_id=7;\n\n--Find customers who placed the largest order:\nselect * from orders;\nselect customer_name, product, amount from orders where \namount= (select max(amount) from orders);\n\nselect * from employees;\n\n--employees in the depart with minimum salary\nselect emp_name, salary from employees where salary = (select min(salary) from employees);\n\n\n--Multi row subquery: returns more than one row.\n--We can use the operators like : IN, ANY, ALL\nselect * from employees;\nupdate employees set salary=28000 where emp_id=1;\n\nselect salary from employees where dept= 'IT';\n\n--employees who earn the same salary as employees in IT dept\n\nselect emp_name, salary, dept from employees where salary \nin (select salary from employees where dept= 'IT');\n\n--\n\nselect * from orders;\n\nalter table orders add category varchar2(100);\n\nupdate orders set category= 'Electronics' ;\n\ninsert into orders values (8, sysdate-2, 'Raj', 'Bike', 200000, 'Automobile');\n\n\n--Find products more expensive than ALL electronics items \nselect customer_name, product, amount, category from orders\nwhere amount > ALL (select amount from orders where category='Electronics');\n\n--amount > max amount in Electronics\n--Product is costlier than every electronic item\n\n\n--DML (Merge): Merge is used when we want to update a row if its exists or\n--insert a new row if its does not exist.\n\ncreate table emp_main\n(\n  id number(5),\n  name varchar(50),\n  salary number(8)\n);\n\ncreate table emp_new\n(\n  id number(5),\n  name varchar(50),\n  salary number(8)\n);\n\ninsert into emp_main values (101, 'Rahul',30000);\ninsert into emp_main values (102, 'Sneha',35000);\n\ninsert into emp_new values (101, 'Rahul',40000);\ninsert into emp_new values (103, 'Amit',28000);\n\nselect * from emp_main;\n\n--What we need:\n--if emp already exist --> Update query\n--if emp does not exist --> insert query\n\nmerge into emp_main m\nusing emp_new n\non (m.id=n.id)\nwhen matched then\nupdate set m.salary=n.salary,m.name=n.name  -- update exisitng employee data\n\nwhen not matched then\ninsert (id, name, salary) -- insert new employee data\nvalues (n.id,n.name,n.salary);"
},
{
    "date": "12-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "10:14 PM",
  "body":   "--Constraints in SQL: Rules apply on table columns to protect data and avoid mistakes.\n--They ensure that the data is unique, not missing and correctly linked between tables.\n\n--1. UNIQUE : to store the value in column which must be unique but can be null\ncreate table users\n(\nuser_id number ,\nemail varchar2(300) unique --> you can insert null values as well\n);\n\n\ndesc users;\n\nalter table users drop constraint  SYS_C007083;\n\nselect * from users;\ndelete from users;\n\ninsert into users values (1, 'abc@gmail.com');\ninsert into users values (3, null);\ninsert into users (user_id) values (4);\n\n--No two users can have the same email\n--Email can be NULL\n\n--2. NOT NULL: Column must have a value, it cannot be empty.\nalter table users modify email varchar2(100) not null;\ndesc users;\ninsert into users (user_id, email) values (8,'sdfgbfg');\n\n\nupdate users  set email='sadfsgdhjcvkbl@gmai.com'  where user_id=3;\n--3. PRIMARY KEY: A column that uniquely identifies each row:\n--Cannot be NULL\n--Cannot have duplicate values (Unique values only)\n--Combination of Unique + NOT NULL constraints\n\ndesc users;\n--to declare existing column as primary key\nalter table users add constraint pk_user_id primary key (user_id);\n\ninsert into users (user_id, email) values (8,'abcdefft@gmail.com');\ninsert into users (user_id,email) values (9,'abcdeffgg@gmail.com');\n\n--to remove exisiting primary key from table\nalter table users drop constraint pk_user_id;\n\n--adding and new column and declaring it as primary key:\nalter table users add phone number(10);\nalter table users add constraint pk_phone primary key (phone);\ninsert into users values (6, 'abcui@gmail.com', 7748503253);\n\n--4. CHECK: Used to restrict allowed values. We define a condition. \nselect * from users;\nupdate users set salary=10000;\nalter table users add salary number;\ndesc users;\n\ncreate table users\n(user_id number primary key, -- column level cons\nemail varchar2(100),\nsalary number check (salary >0),\nconstraint ck primary key(user_id, email)\n);\n\ndesc users;\nselect * from users;\n\nupdate users set salary=11000 ;\n\ninsert into users (user_id,email, salary) values (9,'abcd6effgg@gmail.com', 12000);\ninsert into users (user_id,email, salary) values (10,'abcdddefgfgg@gmail.com',13000);\n\ninsert into users (user_id,email, salary) values (11,'abcddeffgg@gmail.com',14000);\n\ninsert into users (user_id,email,salary) values (12,'abcdeffgkg@gmail.com',15000);\n\ninsert into users (user_id,email,salary) values (13,'abcdgeffgkg@gmail.com',16000);\n\ninsert into users (user_id,email,salary) values (14,'abcdeffkkgg@gmail.com',17000);\n\nalter table users modify salary number check (salary > 0);\nalter table users add constraint check_user_id check(user_id<100);\n\nalter table users add Gen varchar2(1) check (gen in ('m', 'f'));\n\n\ndesc users;\ninsert into users (user_id,email,salary) values (15,'abcdeffffkkgg@gmail.com',null);\ninsert into users (user_id,email,salary) values (16,'abcfdeffffkkgg@gmail.com',1);\n\n\n\nalter table users add salary number;\n--adding a new column in table:\nalter table users add phone_no number;\n--applying check contraint on exisiting column\nalter table users add constraint chk_phone check (regexp_like(phone_no, '^[0-9]{10}$'));\nselect * from users;\ninsert into users values (12, 'abcsduiddfsdf@gmail.com',10000, 7485415215);\nalter table users add constraint chk_salary check (salary>=10000);\n\n--applying check contraint while creating table:\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0) -- check constraint\n);\n\n--5. DEFAULT: If no value is entered, SQL will insert a default value automatically.\nalter table users add status varchar2(100) default 'Pending';\n\ndesc users;\n--applying default constraint on exiting column\nalter table users modify status varchar2(100) default 'Pending';\nselect * from users;\ninsert into users  (user_id, email, salary) values\n(20, 'adbcdujuhhjusiguduhhidd@gmail.com',10000); --implicit insertion\n\ninsert into users  values\n(21, 'adbcdujuhhjusiguduhhhhidd@gmail.com',10000, 'Hired'); --explicit insertion\n\n--applying default contraint while creating table:\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0), -- check constraint\nstatus varchar2(50) default 'Pending' -- default constraint\n);\n\n--6. COMPOSITE KEY: A primary key made of 2 or more columns together.\nalter table users add constraint pk_userid_email primary key (user_id, email) ;\nalter table users drop constraint SYS_C007082;\nselect * from users;\ninsert into users values (29, 'scfdfd@gmail.com', 15000, 'Hired');\n\ndesc users;\n\nselect * from users;\n--dropping the exisiting primary key:\nalter table users drop constraint PK_USERID;\n--creating a composite key for two columns on existing table\nalter table users add constraint ck_userid_email primary key (user_id, email);\n--applying composite key contraint while creating table:\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary >0), -- check constraint\nstatus varchaar2(50) default 'Pending', -- default constraint\nconstraint com_key primary key(user_id, email) --composite key\n);\n\n--Column level and Table level constraints:\n--Column level constraint: applied on single column\n--Table level constraint: applied on multiple columns\ncreate table users\n(user_id number,\nemail varchar2(100),\nsalary number check (salary > 0), -- check constraint -- column level constraint\nstatus varchar2(50) default 'Pending', -- default constraint  -- column level constraint\nage number,\nconstraint com_key primary key(user_id, email), --composite key -- table level constraint\n);\n\n--Naming conventions:\n--name given to constraints while defining it.\nalter table users add constraint ck_userid_email primary key (user_id, email);\n--ck_user_id_email -- name of the constraint\n\n--disable and enable constraint:\nalter table users modify constraint PK_email enable novalidate;\n\ninsert into users values (3, 'b@gmail.com', 15000, 'Hired');\n\nalter table users add constraint PK_email primary key (email);\n\n--Recap:\nConstraints: UNIQUE, NOT NULL, CHECK, DEFAULT, COMPOSITE PK\nColumn Level and Table Level Constraints\nNaming Conventions\nEnable and Disbale Constraints\nEnable Novalidate/ Enable Validate"
},
{
    "date": "13-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "02:51 PM",
  "body":   "--Database Link: Is a schema object in Oracle that allows us to \n--access tables, views, procedures in another database as if they were local.\n\n--Used when data is stored in different databases/servers.\nselect * from emp;\n\nselect * from students;\ngrant create database LINK to dbs2;\ngrant select, insert, delete on emp to dbs2;\n\n--to define quota limit\nalter user dbs2 quota unlimited on users;\n\n--Create database link in DBS2 connection:\ncreate database link dbs_link\nconnect to system identified by DBS\nusing '(Description=\n(Address=(protocol=TCP)(host=localhost)(port=1521))\n(connect_data=(sid=XE)))';\n--OR\ncreate database link dbs_link1\nconnect to system identified by DBS\nusing 'localhost:1521/XE';\n\n--to delete a database link\ndrop database link DBS_LINK1;\n\n--to give all privileges or DBA access\nGRANT  all privileges to dbs2;\nGRANT  DBA to dbs2;\n--to give any table access\ngrant select any table to dbs2;\n\nrevoke all PRIVILEGES from dbs2;\n\n---Group by clause: is used to group rows that have the same values\n--in one or more columns and allows you to perform aggregate functions like\n--SUM, COUNT, AVG, etc\nselect * from sales;\n\ninsert into sales values ('Mobile', 50000, 'Delhi');\ninsert into sales values ('Laptop', 60000, 'Mumbai');\ninsert into sales values ('Mobile', 25000, 'Pune');\ninsert into sales values ('Laptop', 45000, 'Delhi');\ninsert into sales values ('Mobile', 10000, 'Mumbai');\ninsert into sales values ('Laptop', 60000, 'Pune');\ninsert into sales values ('Mobile', 30000, 'Delhi');\n\n--total sales per product\nselect product, sum(amount) as total_sales from sales group by product;\n--Total sales in each city\nselect city, sum(amount) as total_sales from sales group by city;\n--total sales per city per product\nselect city,product, sum(amount) as total_sales from sales group by city, product;\n\n--having clause: is used to filter grouped (aggregated) data.\n--it works after group by and is mainly used with aggregate functions like count, sum, min, max, etc\n\n--Where: filter the individual row.\n--having clause: filters the group.\n\n--show products whose total sales amount is greater than 50000\nselect product, sum(amount) as total_sales from sales group by product\nhaving sum(amount) > 192000;\n\n--show products that are sold more than one time\nselect product, count(*) as product_count from sales group by product\nhaving count(*) > 5;\n\nselect * from emp;\n\n--Where + having clause\n--For Delhi only, show products whose total sales > 50000\nselect city, product, sum(amount) as total_sales  from sales\nwhere city= 'Delhi'\ngroup by product, city\nhaving sum(amount) > 50000;"
},
{
    "date": "13-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "11:51 PM",
  "body":   "--Multi row functions:\n--Aggregate functions: sum, min, max, count, avg\n--Group by clause\n--Having clause\n\n--Group by clause: is used to group rows that have the same values in one or more\n--columns and then we apply aggegate functions on each group.\n\ndesc sales;\ncreate table sales\n(\nproduct varchar2(100),\namount number,\ncity varchar2(100)\n);\n\n\ninsert into sales  values ('Mobile', 12000, 'Pune');\ninsert into sales values ('Laptop', 40000, 'Pune');\ninsert into sales values ('Mobile', 15000, 'Mumbai');\ninsert into sales values ('Laptop', 35000, 'Mumbai');\n\nselect * from sales;\n\n--to find total sales per product\nselect product, sum(amount) as total_sales from sales group by product;\n\n--Here we have grouped all 'Mobile' together and all 'Laptop' together.\nselect * from sales;\n--Total sales in each city\nselect city, sum(amount) as total_sales from sales group by city;\n\n--total sales per city per product\nselect city, product, sum(amount) as total_sales from sales group by city, product;\n\n--having clause: is used to filter grouped (aggregated) data.\n--it works after group by and is mainly used with aggregate functions like count, sum, min, max, etc\n\n--Where: filter the individual row.\n--having clause: filters the group.\n\n--show products whose total sales amount is greater than 50000\nselect product, sum(amount) as total_sales from sales group by product\nhaving sum(amount) > 50000;\n\n--show products that are sold more than one time\nselect product, count(*) as product_count from sales group by product\nhaving count(*) > 5;\n\nselect * from emp;\n\n--Where + having clause\n--For Delhi only, show products whose total sales > 50000\nselect city, product, sum(amount) as total_sales  from sales\n--where city= 'Mumbai'\ngroup by product, city\nhaving sum(amount) > 50000 and city='Delhi';\n\n\n--Subquery: When a query is used inside a query then its called as sub-query or nested query.\n--1. Single-row Subquery: returns only one row and one column as output. It is \n--used with comparison operators, like : =, <, >, <=, >=, !=\nselect * from employees;\n\n--Find employees earning more than the average salary:\nselect emp_name, salary from employees where salary > (select avg(salary) from employees);\n\n--select avg(salary) from employees: return one value --> avg salary\n--main query select all employees earning more than avg salary value.\n\n\nselect * from orders;\n\nalter table orders add amount number;\n\nupdate orders set amount = 10000 where order_id=1;\nupdate orders set amount = 12000 where order_id=2;\nupdate orders set amount = 14000 where order_id=3;\nupdate orders set amount = 20000 where order_id=4;\nupdate orders set amount = 25000 where order_id=5;\nupdate orders set amount = 40000 where order_id=6;\nupdate orders set amount = 62000 where order_id=7;\n\n--Find customers who placed the largest order:\nselect * from orders;\nselect customer_name, product, amount from orders where \namount= (select max(amount) from orders);\n\nselect * from employees;\n\n--employees in the depart with minimum salary\nselect emp_name, salary, dept from employees where salary = \n(select max(salary) from employees);\n\n\n--Multi row subquery: returns more than one row.\n--We can use the operators like : IN, ANY, ALL\nselect * from employees;\nupdate employees set salary=28000 where emp_id=1;\n\nselect salary from employees where dept= 'IT';\n\n--employees who earn the same salary as employees in IT dept\n\nselect emp_name, salary, dept from employees where\nsalary in (select salary from employees where dept= 'IT');\n\n--\n\nselect * from orders; where category='Electronics';\n\nalter table orders add category varchar2(100);\n\nupdate orders set category= 'Electronics' ;\n\ninsert into orders values (8, sysdate-2, 'Raj', 'Bike', 200000, 'Automobile');\n\n\n--Find products more expensive than ALL electronics items \nselect customer_name, product, amount, category from orders\nwhere amount > ALL (select (amount) from orders where category='Electronics');\n\n--amount > max amount in Electronics\n--Product is costlier than every electronic item\n\n--Recap: \n--1. Group by clause\n--2. Having clause\n--3. Subqueries : single row and multi row"
},
{
    "date": "15-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "03:07 PM",
  "body":   "--Subquery: When a query is used inside a query then its called as sub-query or nested query.\n--1. Single-row Subquery: returns only one row and one column as output. It is \n--used with comparison operators, like : =, <, >, <=, >=, !=\nselect * from employees;\n\n--Find employees earning more than the average salary:\nselect emp_name, salary from employees where salary > (select avg(salary) from employees where emp_id in (1,2,3));\n\n--select avg(salary) from employees: return one value --> avg salary\n--main query select all employees earning more than avg salary value.\n\n\nselect * from orders;\n\nalter table orders add amount number;\n\nupdate orders set amount = 10000 where order_id=1;\nupdate orders set amount = 12000 where order_id=2;\nupdate orders set amount = 14000 where order_id=3;\nupdate orders set amount = 20000 where order_id=4;\nupdate orders set amount = 25000 where order_id=5;\nupdate orders set amount = 40000 where order_id=6;\nupdate orders set amount = 62000 where order_id=7;\n\n--Find customers who placed the largest order:\nselect * from orders;\n\nselect * from orders where amount= (select max(amount) from orders);\n\nselect * from employees;\n\n--employees in the depart with minimum salary\nselect * from employees where salary = \n(select min(salary) from employees);\n\n\n--Multi row subquery: returns more than one row.\n--We can use the operators like : IN, ANY, ALL\nselect * from employees;\nupdate employees set salary=28000 where emp_id=1;\n\nselect salary from employees where dept= 'IT';\n\n--employees who earn the same salary as employees in IT dept\n\nselect * from employees where\nsalary in (select salary from employees where dept= 'IT');\n\n--\n\nselect * from orders; where category='Electronics';\n\nalter table orders add category varchar2(100);\n\nupdate orders set category= 'Electronics' ;\n\ninsert into orders values (8, sysdate-2, 'Raj', 'Bike', 200000, 'Automobile');\n\nselect sum(amount) from orders where category='Electronics';\nselect * from  orders;\n\n--Find products more expensive than ALL electronics items \nselect * from orders\nwhere amount > ALL (select (amount) from orders where category='Electronics');\n\n--amount > max amount in Electronics\n--Product is costlier than every electronic item\n\nSELECT * FROM EMPloyees\nWHERE SALARY  in (SELECT dept, AVG(SALARY) FROM EMPloyees GROUP BY dept) ;\n\n--For every emp, db find max salary in that department, return only the top earner.\n\n--Corelated Subquery: is a subquery that depends on the outer query.\n--It runs once for each row processed by the outer query.\n\n--Basic Syntax:\n\nselect * from outer_table o\nwhere column >\n(\nselect agg_fun(column) from inner_table where inner_table.key=o.key\n);\n--highest paid employee per department:\nselect * from employees;\n\nselect * from employees o\nwhere salary =\n(\nselect max(salary)\nfrom employees where dept=o.dept\n);\n\n\n--orders whose amount is greater than avg order amount of that customer\nselect * from orders o where amount >\n(\nselect avg(amount) from orders where customer_name=o.customer_name\n);"
},
{
    "date": "15-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "09:24 PM",
  "body":   "--DCL statements:\n--DCL (Grant and revoke)\n--to create a new user\ncreate user dbs11 identified by dbs11user;\n\n--to grant session access\ngrant create session to dbs11;\n\ngrant all PRIVILEGES to dbs11;\n\nalter user dbs11 quota unlimited on users;\n\nalter user dbs11 default TABLESPACE users;\n\n\nalter system kill session '8, 697';\n\n\nselect * from all_constraints where table_name='COURSE';\n\nselect * from emp;\n\n--GRant: to give permission of any db object\ngrant all PRIVILEGES on emp to dbs11;\n\n--DECODE(): works like IF-ELSE/CASE statement:\nselect * from emp;\n\nalter table emp add dept_no number;\n\nupdate emp set dept_no=10 where emp_id_*"
},
{
    "date": "16-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "04:24 PM",
  "body":   "-- FOREIGN KEY:\n--What is a Foreign Key?\n--A foreign key is a column (or set of columns) in one table that links to the primary key/unique key of another table.\n--This value must exist in that other table.\n--Purpose: To maintain relationships between tables and ensure referential integrity (no orphan records).\n--Table1: students:\nCREATE TABLE Students (\n    stu_id number PRIMARY KEY,  --column level constraint\n    name VARCHAR2(100)\n);\n\ndesc students;\n\n--Table 2 : enrollments:\nCREATE TABLE enrollments (\n    enroll_id number PRIMARY KEY, --column level\n    stu_id number,\n    course_name VARCHAR2(100),\n    CONSTRAINT fk_stud_course FOREIGN KEY (stu_id)\n        REFERENCES Students(stu_id) --table level columns\n);\ndrop table enrollments;\ndesc enrollments;\n\n--stu_id in Enrollments is a foreign key.\n--It points to stu_id in Students.\n--This means you cannot insert an enrollment unless that stu_id already exists in the Students table.\n\nINSERT INTO Students VALUES (101, 'A');\nINSERT INTO Students VALUES (102, 'B');\nINSERT INTO Students VALUES (103, 'C');\nINSERT INTO Students VALUES (104, 'D');\nselect * from students;\n\nINSERT INTO Enrollments VALUES (3, 101, 'Java'); --inserted successfully.\nINSERT INTO Enrollments VALUES (2, 105, 'Java'); --integrity constraint voilated\n\nselect * from enrollments;\nalter table enrollments modify stu_id number unique ;\ndelete from enrollments where enroll_id=3;\n\nselect * from emp;\n--Why Disable/Enable Constraints?\n--Sometimes you want to:\n--Disable constraints ? temporarily stop checks (e.g., while bulk inserting data).\nALTER TABLE Enrollments disable CONSTRAINT FK_STUD_COURSE;\nINSERT INTO Enrollments VALUES (7, 107, 'Java');\n\n--Enable constraints ? turn them back on to enforce rules again.\nALTER TABLE Enrollments modify CONSTRAINT FK_STUD_COURSE enable novalidate;\n\n--dropping a constraint\nALTER TABLE emp drop CONSTRAINT CK_EMP_ID_MOBILE_NO;\nselect * from emp;\n--composite primary key\nalter table emp add constraint ck_empid_mobile primary key (emp_id, mobile_no);\n\n--Data Loader: It is used to load the data from csv or CTL file\n--1. CSV data import: To import the data from CSV file into database table.\n--Go to Table -> Import Data -> Select CSV file and perform import.\n\n--2. CTL (Control File Import):\n--create .ctl file\n--Syntax:\n\nLOAD DATA\nINFILE 'students.csv'\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\n--Above syntax is to add the new data into existing table \"students\" from the csv file named as \"students\"\n\n--Syntax2: To add the data given in ctl file itself into database table\nLOAD DATA\nINFILE *\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\nBEGINDATA\n116, Arjun\n117, Riya\n118, Shyam\n\n--How to save ctl file:\n--1.Click on Save As\n--2.Give name of file \"students.ctl\"\n--3.Save file type: All files\n--4.Encoding: ANSI\n\n--To open cmd and run the below command from the path where your ctl and csv file is present\nsqlldr userid=system/DBS control=students.ctl\n\n--Table: STudents\n--Columns stu_id, name\n--csv file: students.csv\n--ctl file: students.ctl\n\nSELECT * FROM STUDENTS;"
},
{
    "date": "16-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "09:05 PM",
  "body":   "--Multi row functions:\n--Aggregate functions: sum, min, max, count, avg\n--Group by clause\n--Having clause\n\n--Group by clause: is used to group rows that have the same values in one or more\n--columns and then we apply aggegate functions on each group.\n\ndesc sales;\ncreate table sales\n(\nproduct varchar2(100),\namount number,\ncity varchar2(100)\n);\n\n\nselect * from sales;\n\ninsert into sales  values ('Mobile', 12000, 'Pune');\ninsert into sales values ('Laptop', 40000, 'Pune');\ninsert into sales values ('Mobile', 15000, 'Mumbai');\ninsert into sales values ('Laptop', 35000, 'Mumbai');\n\nselect * from sales;\n\n--to find total sales per product\nselect product, sum(amount) as total_sales from sales group by product;\n\n--Here we have grouped all 'Mobile' together and all 'Laptop' together.\nselect * from sales;\n\n--Total sales in each city\nselect city, sum(amount) as total_sales from sales group by city;\n\n--total sales per city per product\nselect  product, sum(amount) as total_sales from sales group by  product;\n\n--having clause: is used to filter grouped (aggregated) data.\n--it works after group by and is mainly used with aggregate functions like count, sum, min, max, etc\n\n--Where: filter the individual row.\n--having clause: filters the group.\n\n--show products whose total sales amount is greater than 50000\nselect product, sum(amount) as total_sales from sales group by product\nhaving sum(amount) > 192000;\n\n--show products that are sold more than five time\nselect product, count(*) as product_count from sales group by product\nhaving count(*) > 5;\n\nselect * from emp;\n\n--Where + having clause\n--For Delhi only, show products whose total sales > 50000\n--where clause\nselect city, product, sum(amount) as total_sales  from sales\nwhere city='Delhi'\ngroup by product, city\nhaving sum(amount) > 50000;\n\n--multi conditions in having clause\nselect city, product, sum(amount) as total_sales  from sales\ngroup by product, city\nhaving sum(amount) > 50000 and city='Delhi';\n\n\n--Subquery: When a query is used inside a query then its called as sub-query or nested query.\n\n--1. Single-row Subquery: returns only one row and one column as output. It is \n--used with comparison operators, like : =, <, >, <=, >=, !=\nselect * from employees;\n\n--Find employees earning more than the average salary:\nselect emp_name, salary from employees where salary >\n(select avg(salary) from employees);\n\n--select avg(salary) from employees: return one value --> avg salary\n--main query select all employees earning more than avg salary value.\n\n\nselect * from orders;\n\nalter table orders add amount number;\n\nupdate orders set amount = 10000 where order_id=1;\nupdate orders set amount = 12000 where order_id=2;\nupdate orders set amount = 14000 where order_id=3;\nupdate orders set amount = 20000 where order_id=4;\nupdate orders set amount = 25000 where order_id=5;\nupdate orders set amount = 40000 where order_id=6;\nupdate orders set amount = 62000 where order_id=7;\n\n--Find customers who placed the largest order:\nselect * from orders;\n\nselect customer_name, product, amount from orders where \namount = (select max(amount) from orders);\n\nselect * from employees;\n\n--employees in the depart with minimum salary\nselect emp_name, salary, dept from employees where salary = \n(select max(salary) from employees);\n\n\n--Multi row subquery: returns more than one row.\n--We can use the operators like : IN, ANY, ALL\nselect * from employees;\nupdate employees set salary=28000 where emp_id=1;\n\nselect salary from employees where dept= 'IT';\n\n--employees who earn the same salary as employees earning in IT dept\n\nselect emp_name, salary, dept from employees where\nsalary in (select salary from employees where dept= 'IT');\n\n\n\nselect * from orders; where category='Electronics';\n\nalter table orders add category varchar2(100);\n\nupdate orders set category= 'Electronics' ;\n\ninsert into orders values (8, sysdate-2, 'Raj', 'Bike', 200000, 'Automobile');\n\nselect * from orders;\n--Find products more expensive than ALL electronics items \nselect customer_name, product, amount, category from orders\nwhere amount > ALL (select (amount) from orders where category='Electronics');\n\nselect sum(amount) from orders where  category='Electronics';\n--amount > max amount in Electronics\n--Product is costlier than every electronic item\n\n--Corelated Subquery: is a subquery that depends on the outer query.\n--It runs once for each row processed by the outer query.\n\n--Basic Syntax:\n\nselect * from outer_table o\nwhere column >\n(\nselect agg_fun(column) from inner_table where inner_table.key=o.key\n);\n--highest paid employee per department:\nselect * from employees;\n\nselect * from employees o\nwhere salary =\n(\nselect max(salary)\nfrom employees where dept=o.dept\n);\n\nselect * from orders;\n--orders whose amount is greater than avg order amount of that customer\nselect * from orders o where amount >\n(\nselect avg(amount) from orders where customer_name=o.customer_name\n);\n\nselect * from students;\ndesc students;\n--Data Loader: It is used to load the data from csv or CTL file\n--1. CSV data import: To import the data from CSV file into database table.\n--Go to Table -> Import Data -> Select CSV file and perform import.\n\n--2. CTL (Control File Import):\n--create .ctl file\n--Syntax:\n\nLOAD DATA\nINFILE 'students.csv'\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\n--Above syntax is to add the new data into existing table \"students\" from the csv file named as \"students\"\n\n--Syntax2: To add the data given in ctl file itself into database table\nLOAD DATA\nINFILE *\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\nBEGINDATA\n116, Arjun\n117, Riya\n118, Shyam\n\n--How to save ctl file:\n--1.Click on Save As\n--2.Give name of file \"students.ctl\"\n--3.Save file type: All files\n--4.Encoding: ANSI\n\n--To open cmd and run the below command from the path where your ctl and csv file is present\nsqlldr userid=system/DBS control=students.ctl\n\n--Table: STudents\n--Columns stu_id, name\n--csv file: students.csv\n--ctl file: students.ctl\n\nSELECT * FROM STUDENTS;"
},
{
    "date": "17-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
"subject": "SQL",
    "time": "03:06 PM",
  "body":   "--Data Backup and Migration:\n\nselect * from emp;\n--1. to create a new backup table of the main table and push\n--all the data from main table.\n\ncreate table emp_bkp as select * from emp;\n\nselect * from emp_bkp;\ndelete from emp_bkp;\n\n--2. Export Wizard (SQL/ CSV):\n\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (102,'Sneha',40000.1245,105,4524253658,to_date('10-DEC-2025','DD-MON-RRRR'),5000,'A',10);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (104,'Rohit',35000,106,957586524,null,3000,'I',20);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (105,'Shyam',75000,null,7748526525,null,null,'A',10);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (106,'Ram',40000,null,887542536,null,2000,'A',30);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (107,'Raman',45000,null,452526538,null,null,'I',20);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (108,'MOhan',46000,null,7474745252,null,null,'I',30);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (109,'Aman',41000,107,8523698547,null,4000,null,null);\n\n--Data Loader: It is used to load the data from csv or CTL file\n--1. CSV data import: To import the data from CSV file into database table.\n--Go to Table -> Import Data -> Select CSV file and perform import.\n\n--2. CTL (Control File Import):\n--create .ctl file\n--Syntax:\ndesc students;\nselect * from students;\nLOAD DATA\nINFILE 'students.csv'\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\n--Above syntax is to add the new data into existing table \"students\" from the csv file named as \"students\"\n\n--Syntax2: To add the data given in ctl file itself into database table\nLOAD DATA\nINFILE *\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\nBEGINDATA\n116, Arjun\n117, Riya\n118, Shyam\nselect * from students;\n--How to save ctl file:\n--1.Click on Save As\n--2.Give name of file \"students.ctl\"\n--3.Save file type: All files\n--4.Encoding: ANSI\n\n--To open cmd and run the below command from the path where your ctl and csv file is present\nsqlldr userid = system/DBS control = students.ctl\n\n--Table: STudents\n--Columns stu_id, name\n--csv file: students.csv\n--ctl file: students.ctl\n\nSELECT * FROM STUDENTS;\n\n--Tickets in SN:\n\n--Priority of tickets: P1, P2, P3, P4\n\n--P1 - Highest priority ticket (Response: within 10 mins, resolution time: 1-3 hrs)\n--P2 - Lower: (Response: within 30 mins, resolution time: 4-7 hrs)\n--P3 - Lower than P2: (Response: within 1-3 hours, resolution time: 10-12 hrs/ 2-3 days)\n--P4 - Lowest priority ticket: (Response: within 1-2 days, resolution time: 5-7 days)\n\n--Code Related issue: 1. Check application logs, find the error in log file\n--Determine the error is related to database, code, server or Infrastructure\n\n--Database related issue: error: ORA: DB team connect and you need to share\n--the error log\n\n--Server related issue: 404, 402, 403, 501 -- You need to connect with Wintel, \n--Linux, Unix teams\n\n--Code related issue: action=index.java, actions=index.controller,\n--Null Pointer exception, array index out of bound\n--To coordinate with development team and testing team\n\nselect * from students;\n\ndesc students;\n\nalter table students add mobile number not null;\n\nselect * from enrollments;"
},
{
    "date": "17-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
"subject": "SQL",
    "time": "09:08 PM",
  "body":   "--Data Backup and Migration:\n\nselect * from emp_bkp;\n--1. to create a new backup table of the main table and push\n--all the data from main table.\n\ncreate table emp_bkp as select * from emp;\n\n\nselect * from emp;\ndelete from emp_bkp;\n\n--2. Export Wizard (SQL/ CSV):\n\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (102,'Sneha',40000.1245,105,4524253658,to_date('10-DEC-2025','DD-MON-RRRR'),5000,'A',10);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (104,'Rohit',35000,106,957586524,null,3000,'I',20);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (105,'Shyam',75000,null,7748526525,null,null,'A',10);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (106,'Ram',40000,null,887542536,null,2000,'A',30);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (107,'Raman',45000,null,452526538,null,null,'I',20);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (108,'MOhan',46000,null,7474745252,null,null,'I',30);\nInsert into EMP_BKP (EMP_ID,NAME,SALARY,MANAGER_ID,MOBILE_NO,HIRE_DATE,INCENTIVE,STATUS,DEPT_NO) values (109,'Aman',41000,107,8523698547,null,4000,null,null);\n\n\n--Data Loader: It is used to load the data from csv or CTL file\n--1. CSV data import: To import the data from CSV file into database table.\n--Go to Table -> Import Data -> Select CSV file and perform import.\ndelete  from emp;\n--2. CTL (Control File Import):\n--create .ctl file\n--Syntax:\ndesc students;\nselect * from students;\nLOAD DATA\nINFILE 'students.csv'\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\n\nselect * from emp; where emp_id >=110;\n--Above syntax is to add the new data into existing table \"students\" from the csv file named as \"students\"\n\n--Syntax2: To add the data given in ctl file itself into database table\nLOAD DATA\nINFILE *\nAPPEND\nINTO TABLE students\nFIELDS TERMINATED BY ','\n(\nstu_id,\nname\n)\nBEGINDATA\n116, Arjun\n117, Riya\n118, Shyam\nselect * from students;\n--How to save ctl file:\n--1.Click on Save As\n--2.Give name of file \"students.ctl\"\n--3.Save file type: All files\n--4.Encoding: ANSI\n\n--To open cmd and run the below command from the path where your ctl and csv file is present\nsqlldr userid = system/DBS control = students.ctl\n\n--Table: STudents\n--Columns stu_id, name\n--csv file: students.csv\n--ctl file: students.ctl\n\nSELECT * FROM STUDENTS;\nSELECT * FROM STUDENT1;\n\nCREATE TABLE STUDENT1\n(\nSTU_ID NUMBER UNIQUE,\nNAME VARCHAR2(100)\n);\n\n\n--Create a backup table with original table schema and dependencies\n\n  CREATE TABLE EMP_bkp1\n   (   \"EMP_ID\" NUMBER, \n    \"NAME\" VARCHAR2(100 BYTE), \n    \"SALARY\" NUMBER, \n    \"MANAGER_ID\" NUMBER, \n    \"MOBILE_NO\" NUMBER, \n    \"HIRE_DATE\" DATE, \n    \"INCENTIVE\" NUMBER, \n    \"STATUS\" VARCHAR2(5 BYTE), \n    \"DEPT_NO\" NUMBER, \n     CONSTRAINT \"CK1_EMPID_MOBILE\" PRIMARY KEY (\"EMP_ID\", \"MOBILE_NO\")\n  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS \n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"SYSTEM\"  ENABLE\n   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING\n  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645\n  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)\n  TABLESPACE \"SYSTEM\" ;\n  \n  \n  select * from emp_bkp1;\n  --Insert data of original table in backup table\n  insert into emp_bkp1 select * from emp;\n\n\n--Database Link: Is a schema object in Oracle that allows us to \n--access tables, views, procedures in another database as if they were local.\n\n--Used when data is stored in different databases/servers.\n\ngrant create database LINK to dbs5;\n\n--Create database link in DBS2 connection:\ncreate database link dbs_link\nconnect to system identified by DBS\nusing '(Description=\n(Address=(protocol=TCP)(host=localhost)(port=1521))\n(connect_data=(sid=XE)))';\n--OR\ncreate database link dbs_link1\nconnect to system identified by DBS\nusing 'localhost:1521/XE';\n\n\n--to access data of source table using db link in DBS2 connection:\nselect * from emp@dbs_link1 ;\n--to delete a database link\ndrop database link DBS_LINK1;"
},
{
    "date": "18-DEC-2025",
    "session": "Afternoon",
    "title": "Practice Session",
    "subject": "LINUX",
    "time": "03:22 PM",
  "body":   "What is UNIX?\nIt is an Operating System (OS) like Windows or DOS.\n\nWhy use Unix ?\n Multiuser OS\n Multi-Tasking\n Time sharing OS\n Network Capability\n Has Pattern Matching Capability\n Has Programming Facility\n Shell Script\n Perl Script\n Secured\n Virus Free\n\nVariants of Unix:\n1. AIX (IBM)\n2. Linux (Redhat)\n3. Linux (Ubuntu)\n4. Solaris (Sun Microsystems)\n5. HP-UX\n\nCorporate use of UNIX\n1. Automation\n2. Monitoring\n3. To write scripts for job scheduling tools\n4. Job scheduling and Control\n5. Scripting to handle critical business operations\n6. Unix uses less memory to run app services\n7. Multiple users can login to one server at a time using virtual machines\n8. To store large log files\n9. Control Execution of Processes\n\nDifference Between UNIX and LINUX:\n\nUNIX (AIX)\n----------------\n1. License Based\n2. Costly\n3. Different flavors of Unix have different cost structures according to vendors\n\nLinux\n----------------\n1. Open Source\n2. Cheaper than AIX and Windows\n3. Linux can be freely distributed, downloaded freely, and distributed through magazines or books. There are priced versions also, but they are normally cheaper than Windows.\n\nUNIX Architecture:\n\nUser Applications --> Unix Shell --> Unix Kernel --> System Hardware\n\nUnix Shell Types:\n1. Bash\n2. Bourne\n3. Korn\n4. C Shell\n\nUnix File Structure:\n\n           / (root)\n              |\n-----------------------------------\n |    |    |   |   |    |    |   |\n bin  boot mnt etc dev home lib var"
},
{
    "date": "18-DEC-2025",
    "session": "Evening",
    "title": "Practice Session",
    "subject": "LINUX",
    "time": "11:22 PM",
  "body":   "What is UNIX?\nIt is an Operating System (OS) like Windows or DOS.\n\nWhy use Unix ?\n Multiuser OS\n Multi-Tasking\n Time sharing OS\n Network Capability\n Has Pattern Matching Capability\n Has Programming Facility\n Shell Script\n Perl Script\n Secured\n Virus Free\n\nVariants of Unix:\n1. AIX (IBM)\n2. Linux (Redhat)\n3. Linux (Ubuntu)\n4. Solaris (Sun Microsystems)\n5. HP-UX\n\nCorporate use of UNIX\n1. Automation\n2. Monitoring\n3. To write scripts for job scheduling tools\n4. Job scheduling and Control\n5. Scripting to handle critical business operations\n6. Unix uses less memory to run app services\n7. Multiple users can login to one server at a time using virtual machines\n8. To store large log files\n9. Control Execution of Processes\n\nDifference Between UNIX and LINUX:\n\nUNIX (AIX)\n----------------\n1. License Based\n2. Costly\n3. Different flavors of Unix have different cost structures according to vendors\n\nLinux\n----------------\n1. Open Source\n2. Cheaper than AIX and Windows\n3. Linux can be freely distributed, downloaded freely, and distributed through magazines or books. There are priced versions also, but they are normally cheaper than Windows.\n\nUNIX Architecture:\n\nUser Applications --> Unix Shell --> Unix Kernel --> System Hardware\n\nUnix Shell Types:\n1. Bash\n2. Bourne\n3. Korn\n4. C Shell\n\nUnix File Structure:\n\n           / (root)\n              |\n-----------------------------------\n |    |    |   |   |    |    |   |\n bin  boot mnt etc dev home lib var"
}
]